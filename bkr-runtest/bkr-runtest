#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

# Author: jiyin@redhat.com
# A beaker client tool, Read testlist from file/stdin(generated by lstest), and
#   call gen_job_xml generate xml files and submit them to beaker server.

lappend ::auto_path $::env(HOME)/lib /usr/local/lib /usr/lib64 /usr/lib
package require getOpt 1.0
package require runtestlib
namespace import ::getOpt::* ::runtestlib::*
source $::runtestConf

# global var
set prog [file tail $argv0]
array set Opt {}
array set InvalidOpt {}
set Args [list]
set ForwardOpt {}
set OptionList {
  *b0 {Dummy "\n  Base options:"}
	help   {arg n	help {Print this usage}}	h {link help}
	dryrun {arg o	help {Just generate XML file(s), not submit job to beaker}}	n {link dryrun}
	merge  {arg n	help {Merge all recipeSets in one job XML}}	m {link merge}
	alone  {arg n	help {Submit all tests separately, one case one recipe}}
	wb-format       {arg y	help {Customize whiteboard, default WB_FORMAT in see /etc/bkr-client-improved/bkr-runtest.conf}}
	wb-comment      {arg y	help {Add customer string in the default whiteboard}}
	d      {arg n   help {debug mode}}

	raw    {arg n	help {Do not parse subtest.desc} hide y}	r {link raw hide y}
	e      {arg o	help {Call `expand_testlist [ployConf]` to expand testList} hide y}

  *0 {Dummy "\n  Options for job configuration:"}
	restraint		{forward y arg o	help {Use restraint harness instead of beach}}
	cc			{forward y arg m	help {Notify additional e-mail address on job completion}}
	job-owner		{forward y arg y	help {Submit job on behalf of USERNAME (submitting user must be a submission delegate for job owner)}}
	wb			{forward y arg y	help {Set the whiteboard for this job}}
	whiteboard		{link wb}
	repo			{forward y arg m	help {Configure repo at <URL> in the kickstart for installation}}
	repo-post		{forward y arg m	help {Configure repo at <URL> as part of kickstart %post execution}}
	recipe			{forward y arg n	help {Just generate recipeSet node, internal use for runtest -merge}}
	rwb			{forward y arg y	help {Set the whiteboard for the recipe}}
	flag                    {forward y arg y	help {for distinguish repeated run}}
	retention-tag           {forward y arg y        help {e.g: scratch, 60days, 120days, active, active+1, audit}}
	product                 {forward y arg y        help {e.g: cpe:/o:redhat:enterprise_linux:$x:$y}}

  *1 {Dummy "\n  Options for selecting distro tree(s):"}
	family			{forward y arg m	help {Use latest distro of this FAMILY for job, eg. "RedHatEnterpriseLinux6"}}
	tag			{forward y arg m	help {Use latest distro tagged with TAG, eg. "RTT_ACCEPTED" (default: STABLE)}}
	distro			{forward y arg y	help {Use named distro for job)}}
	variant			{forward y arg m	help {Specify the distro variant}}
	arch			{forward y arg y	help {Specify the distro arch}}
	distrorequire		{link dr}
	dr			{forward y arg m	help {distrorequire -dr=key="value"}}

  *2 {Dummy "\n  Options for selecting system(s):"}
	servers			{forward y arg y	help {Include NUMBER server hosts for multi-host test}}
	clients			{forward y arg y	help {Include NUMBER client hosts for multi-host test}}
	hr			{forward y arg m	help {Additional <hostRequires/> for job, example: --hostrequire=labcontroller="lab.example.com"}}
	hostrequire		{link hr}
	kv			{forward y arg m	help {Require system with matching legacy key-value, example: --keyvalue=NETWORK=e1000}}
	keyvalue		{link kv}
	machine			{forward y arg m	help {Require the machine for job, set comma-separated values for multi-host, example: --machine=SERVER1,CLIENT1}}
	systype			{forward y arg m	help {Require system of TYPE for job (Machine, Prototype, Laptop, ..) default: Machine}}
	ormachine		{forward y arg m	help {Use comma-separated values to set a machine pool, example: --ormachine=HOST1,HOST2,HOST3}}
	random                  {forward y arg n        help {autopick type}}
	hrxml                   {forward y arg y        help {add raw filter in hostrequire node, example: --hrxml='<system><not><fqdn op="like" value="%rmda%" /></not></system>'}}

  *3 {Dummy "\n  Options for selecting special system(s) of networ-qe:"}
	nay-driver		{link netqe-nic-driver	hide y}
	nic-num			{link netqe-nic-num	hide y}
	nay-nic-driver		{link netqe-nic-driver	hide y}
	nay-nic-num		{link netqe-nic-num	hide y}
	nay-nic-model		{link netqe-nic-model	hide y}
	nay-nic-speed		{link netqe-nic-speed	hide y}
	nay-nic-match		{link netqe-nic-match	hide y}
	nay-nic-unmatch		{link netqe-nic-unmatch hide y}
	netqe-nic-driver	{forward y arg o help ""}
	netqe-nic-num		{forward y arg o help ""}
	netqe-nic-model		{forward y arg o help ""}
	netqe-nic-speed		{forward y arg o help ""}
	netqe-nic-match		{forward y arg o help ""}
	netqe-nic-unmatch	{forward y arg o help {These options together generate the machine pool which match required NIC num/driver/model/speed
				- Refer `parse_netqe_nic_info.sh -h`, which is the engine for the translating.
				  Example: --netqe-nic-driver=e1000e --netqe-nic-num=2
				- Use comma-separated values for different machine pool of multihost
				  Example: --netqe-nic-driver=e1000e,any --netqe-nic-num=2 --netqe-nic-speed=1g }}

  *4 {Dummy "\n  Options for setting tasks:"}
	task			{arg m	help {Include named task in job, can use multiple times}}
	taskn			{forward y arg y	help {repeat task 'N' times}}
	param			{forward y arg m	help {Set task params, can use multiple times.
				Use "mh-" prefix to set different value for multihost, example: --param=mh-key=val1,val2}}
	taskparam		{link param}
	nvr			{forward y arg m	help {Specify the kernel(Name-Version-Release) to be installed}}
	install			{forward y arg m	help {Install PACKAGE using /distribution/pkginstall, can use multiple times}}
	upstream		{forward y arg o	help {Specify the kernel src git addr to be installed. --upstream=[git://a.b.c/d][#tag]
				default: git://git.app.eng.bos.redhat.com/linux.git#master}}
	Scratch			{forward y arg m  help {Install scratch built package using /distribution/scratchinstall, can use multiple times}}
	scratch			{forward y arg m  help {same as Scratch, but every specified just apply one host, if in multihost mode}}
	dbgk			{forward y arg n	help {Use the debug kernel}}
	kcov			{forward y arg o	help {Enable kcov for coverage data collection, use arg to specify KDIR, example: --kcov="fs,drivers/net"}}
	kdump			{forward y arg o	help {Enable kdump using /kernel/kdump/setup-nfsdump}}
	cmd			{forward y arg m	help {Add /distribution/command before test task}}
	cmdb			{forward y arg m	help {Add /distribution/command before install kernel}}
	cmd-end 		{forward y arg m	help {Add /distribution/command in the end of the recipe}}
	leap-second		{forward y arg n	help {Add leap-second task}}
	reserve-if-fail		{forward y arg o	help {Reserve the machine if test fail, specify RESERVETIME with s/m/h/d unit, max amount is 99h}}
	reserve			{forward y arg o	help {Reserve system at the end of the recipe}}
	fips                    {forward y arg o	help {enable fips}}
	abrt                    {forward y arg n	help {enable abrt(insert /distribution/crashes/enable-abrt)}}

  *5 {Dummy "\n  Options for installation:"}
	part			{forward y arg m	help {Additional <partitions/> for job, example: --part='fs=xfs name=/mnt/xfs size=10 type=part'}}
	partition		{link part}
	ks-meta			{forward y arg m  help {Pass kickstart metadata OPTIONS when generating kickstart}}
	ks-append		{forward y arg m	help {Specify additional kickstart commands to add to the base kickstart file}}
	ks			{link ks-append hide y}
	ksf			{forward y arg m	help {Similar to --ks-append, but pass the content of a specified file}}
	k-opts			{forward y arg m	help {Pass OPTIONS to kernel during installation}}
	kernel-options		{link k-opts}
	k-opts-post		{forward y arg m	help {Pass OPTIONS to kernel after installation}}
	kernel-options-post	{link k-opts-post}
}

# _parse_ argument
getOptions $OptionList $::argv Opt InvalidOpt Args ForwardOpt
if [info exist Opt(d)] {
	puts "\[$prog\]: Arguments:{$Args}"
	puts "\[$prog\]: ForwardOpt{$ForwardOpt}"
	parray InvalidOpt
	parray Opt
}

# Usage
proc Usage {{detail n}} {
	puts "Usage0: $::prog \[options\] <distro\[,distro,...\]> \[-|testfile...\] \[gen_job_xml options\] "
	puts "Usage1: $::prog \[options\] <family\[,family,...\]> \[-|testfile...\] \[gen_job_xml options\]"
	puts ""
	puts "Example 1: $::prog RHEL-6.6  ~/git/test/kernel/filesystems/nfs/function/"
	puts "Example 2: $::prog RHEL-6.6  ~/git/test/kernel/networking/bonding/failover --netqe-nic-driver=tg3 --netqe-nic-num=2"
	puts "Example 3: $::prog Fedora-22,RHEL-7.2,RHEL-7.2 ~/git/test/nfs-utils/function/pnfs/blklayout"
	puts "Example 4: $::prog RedHatEnterpriseLinux6 --arch=x86_64 --kdump --nvr=kernel-2.6.32-570.el6 # reserve a host"
	puts ""
	if {$detail != "n"} {
		getUsage $::OptionList
	} else {
		puts "* try '$::prog -h|less' to get more detail info about options"
	}
}
proc Usage_bkr_reserve {{detail n}} {
	puts "Usage0: $::prog \[-n\] <distro\[,distro,...\]> \[gen_job_xml options\] "
	puts "Example: $::prog RHEL-6.6 --arch=x86_64 --kdump --nvr=kernel-2.6.32-570.el6"
	puts ""
	if {$detail != "n"} {
		getUsage $::OptionList
	} else {
		puts "* try '$::prog -h|less' to get more detail info about options"
	}
}
proc istty {{chann stdin}} {
	dict exists [fconfigure $chann] -mode
}

if [info exist Opt(help)] {
	if {$prog == "bkr-reservesys"} {
		Usage_bkr_reserve detail
	} else {
		Usage detail
	}
	exit 0
}
if {[llength $Args] < 1} {
	if {$prog == "bkr-reservesys"} {
		Usage_bkr_reserve
	} else {
		Usage
	}
	exit 1
}

set lstest_opts {}
if [info exist Opt(raw)] {
	append lstest_opts {-r}
}

set SubcmdOpt $ForwardOpt
set TestArgList {}
set Idx [lsearch $Args {--}]
if {$Idx == -1} {
	set TestArgList [lrange $Args 1 end]
} else {
	set TestArgList [lrange $Args 1 [expr $Idx-1]]
	lappend SubcmdOpt {*}[lrange $Args [expr $Idx+1] end]
}
if [info exist Opt(d)] {
	puts "\[$prog\]: SubcmdOpt{$SubcmdOpt}"
}

set Distro [lindex $Args 0]
#If Distro is a errata name, process it.
if [regexp -- {^RH[A-Z]{2}-[0-9]{4}:[0-9]+} $Distro] {
	lassign [exec errata2distro_and_pkg $Distro] Distro pkgBuild
	set pkgOpt {--install}
	if [regexp -- {^kernel-} $pkgBuild] {set pkgOpt {--nvr}}
	lappend SubcmdOpt $pkgOpt=$pkgBuild
}

#If Distro is short format
set Distro [expandDistro $Distro]

# Get the test list
set TestList {}
if [info exist Opt(task)] { set TestList [list $Opt(task)] }
set TestListFile {}
if {[llength $TestArgList]==0 && ![istty stdin]} {lappend TestArgList -}
if {[llength $TestArgList]==0 && $TestList == {}} {
	if {$prog != "bkr-reservesys"} {
		puts "\[$prog\]: *Remind*: No test specified, will reserve host($Distro) for you" }
	lappend TestList "/distribution/reservesys Attr: pkg=distrbution topo=singleHost time=12h ssched=no type=Functioal"
} else {
	if {$prog == "bkr-reservesys"} {
		lappend TestList "/distribution/reservesys Attr: pkg=distrbution topo=singleHost time=12h ssched=no type=Functioal"
	} else {
		foreach f $TestArgList {
			if {$f in "-"} {
				set fp stdin
				while {-1 != [gets $fp line]} {
					lappend TestList $line
				}
			} elseif [file isdirectory $f] {
				lappend TestDir $f
				if {![catch {set fp [open "|lstest $f $lstest_opts" r]} err]} {
					while {-1 != [gets $fp line]} {
						lappend TestList $line
					}
					close $fp
				}
			} elseif [file isfile $f] {
				set TestListFile $f
				if {![catch {set fp [open $f]} err]} {
					while {-1 != [gets $fp line]} {
						lappend TestList $line
					}
				}
			}
		}
	}
}

# Expand test list
if [info exist Opt(e)] {
	set ployConf {}
	if {$Opt(e) != ""} {
		set ployConf "$Opt(e)"
	}
	set TestList_tmp [exec mktemp]
	set fp [open $TestList_tmp w]
	foreach test $TestList {
		puts $fp "$test"
	}
	close $fp

	set TestList {}
	if {![catch {set fp [open "|cat $TestList_tmp | expand_testlist $ployConf -d $Distro" r]} err]} {
		while {-1 != [gets $fp line]} {
			lappend TestList $line
		}
		close $fp
	}
	file delete $TestList_tmp
}

# Group the test list
set sschedCnt 0
foreach test $TestList {
	if {[regexp -- {^ *#} $test] == 1} continue
	if {[string trim $test] == ""} continue

	# get key {pkg= ssched= topo= GlobalSetup}
	set key [testinfo recipekey $test]
	if ![regexp -- {.+ ssched=.* topo=.*} $key] {
		puts stderr "\[$prog\]: Warn: recipekey($key) is not standard([lindex $test 0])!"
		continue
	}
	if [info exist Opt(alone)] {regsub {ssched=no} $key {ssched=yes} key}
	if [regexp {ssched=ye} [lindex $key 1]] {
		lset key 1 "ssched=yes.[incr sschedCnt]"
	}
	lappend TestGroup($key) $test
}

# Gen job xml[s] and submit
set TestCnt 0
set TestSumm {}
set gen_opts {}
if [info exist Opt(merge)] {
	set xmlf_merged "job_merged.[clock format [clock seconds] -format %Y%m%d_%H%M].[expr {int(rand()*10000)}].xml"
	lappend SubcmdOpt {-recipe}
}
foreach {tkey tvalue} [array get TestGroup] {
	set testGset $tkey
	set testList $tvalue
	set wbComment {}
	if [info exist Opt(wb-comment)] { set wbComment $Opt(wb-comment) }
	if {$TestListFile != ""} { lappend wbComment "$TestListFile" }

	set wbFormat {}
	if [info exist WB_FORMAT] { set wbFormat $WB_FORMAT }
	if [info exist Opt(wb-format)] { set wbFormat $Opt(wb-format) }

	set gset [genGset $testGset]
	set WB [genWhiteboard $Distro $testGset $testList "$wbFormat" $wbComment]
	if {[llength $testList] == 1} {
		append WB "[testinfo param [lindex $testList 0]]"
	}

	if {[string length $SubcmdOpt]>0} {
		regsub -all "%O" $WB "{$SubcmdOpt}" WB
	} else {
		regsub -all "%O" $WB "" WB
	}

	set jobinfo job_[regsub -all {[^-?,=_a-zA-Z0-9]} $WB {_}]; # substitute special characters
	set jobinfo [regsub -all {_+} $jobinfo {_}];		  # merge duplicate underlines
	set xmlf [string range $jobinfo 0 128].[expr {int(rand()*10000)}].xml; # limit filename length

	if {![catch {set fp \
	  [open "|gen_job_xml -distro=$Distro -F - {-wb=$WB} $SubcmdOpt $gset >$xmlf" w]} err]} {
		foreach t $testList { puts $fp "$t" }
		catch {close $fp} err

		puts "\[$prog\]: processing GlobalSetup: {$gset}"
		puts "\[$prog\]: Generate job XML ==> '$xmlf'"

		if [info exist xmlf_merged] {
			exec sed -n {/retention_tag/,/\/notify/p} $xmlf > ${xmlf_merged}.head
			exec sed -n {/recipeSet/,/\/recipeSet/p} $xmlf >> ${xmlf_merged}.body
			exec sed -n {/\/job/,/$/p} $xmlf > ${xmlf_merged}.tail

			file delete $xmlf
		} else {
			if ![info exist Opt(dryrun)] {
				set status [catch {exec bkr job-submit $xmlf} result]
				puts "$result"
				file delete $xmlf
			} elseif {$Opt(dryrun) != ""} {
				puts [exec cat $xmlf]
				file delete $xmlf
			}
		}
		puts ""
	} else {
		puts "\[$prog\]: Error: fail to write $xmlf\n\n$err"
	}
}

if [info exist xmlf_merged] {
	puts "\[$prog\]: Merged all recipeSets to '$xmlf_merged'"
	set XML [exec cat ${xmlf_merged}.head ${xmlf_merged}.body ${xmlf_merged}.tail]
	file delete ${xmlf_merged}.head
	file delete ${xmlf_merged}.body
	file delete ${xmlf_merged}.tail

	if [info exist TestDir] {set TestList "$TestDir"}
	lassign [genWhiteboard $Distro {merged} $TestList ""] WB tmp
	regsub {<!--(<job .*?>)-->} $XML {\1} XML
	regsub -all {[\&\\]} $WB {\\&} NWB
	regsub {<!--<whiteboard>.*?</whiteboard>-->} $XML "<whiteboard>$NWB</whiteboard>" XML
	regsub {<!--(<notify>)} $XML {\1} XML
	regsub {(</notify>)-->} $XML {\1} XML
	regsub -linestop {<!--(</job>)-->$} $XML {\1} XML

	set fp [open $xmlf_merged w]
	puts $fp $XML
	close $fp

	if ![info exist Opt(dryrun)] {
		set status [catch {exec bkr job-submit $xmlf_merged} result]
		puts "$result"
		file delete $xmlf_merged
	} elseif {$Opt(dryrun) != ""} {
		puts [exec cat $xmlf_merged]
		file delete $xmlf_merged
	}
	file delete $xmlf_merged
}
