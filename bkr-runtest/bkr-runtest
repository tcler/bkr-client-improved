#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

# Author: jiyin@redhat.com
# A beaker client tool, Read testlist from file/stdin(generated by lstest), and
#   call gen_job_xml generate xml files and submit them to beaker server.

lappend ::auto_path $::env(HOME)/lib /usr/local/lib /usr/lib64 /usr/lib
package require yaml
package require getOpt 3.0
package require runtestlib 1.1
namespace import ::getOpt::* ::runtestlib::*

source $::runtestConf
if [file exists $::runtestConfPrivate] { source $::runtestConfPrivate }

# global var
set prog [file tail $argv0]
array set Opt {}
array set InvalidOpt {}
set Args [list]
set ForwardOpt {}
set OptionList {
  "  Base options:" {
	{help h}   {arg n	help {Print this usage}}
	{dryrun n} {arg o	help {Just generate XML file(s), not submit job to beaker}}
	{jobn}     {arg y	help {--jobn=N submit job N times}}
	{merge m}  {arg n	help {Merge all recipeSets in one job XML}}
	alone      {arg n	help {Submit all tests separately, one case one recipe}}
	d          {arg n	help {debug mode}}
	wb-format  {arg y	help {Customize whiteboard, default WB_FORMAT in see /etc/bkr-client-improved/bkr-runtest.conf}}
	wb-comment {arg y	help {Add customer string in the default whiteboard}}
	f          {arg n       help {just do dynamic filter and output test list}}
	F          {arg n       help {output test groups and exit} hide yes}
	task       {arg m	help {Include named task in job, can use multiple times}}
	distro     {arg y	help {Use named distro for job}}
	{prettyxml pretty-xml}  {arg n help {do nothing, just for compat other workflow}}
  }
}
source /usr/share/bkr-client-improved/common-options.tcl
lappend OptionList {*}[string map {"\{arg " "\{forward y arg "} $CommonOptionList]

# _parse_ argument
getOptions $OptionList $::argv Opt InvalidOpt Args ForwardOpt
if [info exist Opt(d)] {
	puts "\[$prog\]: Arguments:{$Args}"
	puts "\[$prog\]: ForwardOpt{$ForwardOpt}"
	parray InvalidOpt
	parray Opt
}
if {[array size InvalidOpt] > 0} {
	puts stderr "{Error} got invalide option\[s\]:"
	foreach {opt value} [array get InvalidOpt] {
		puts stderr "  $opt -> $value"
	}
	exit 1
}

# Usage
proc Usage {{detail n}} {
	puts "Usage0: $::prog \[options\] <distro\[,distro,...\]> \[-|testfile...\] \[gen_job_xml options\] "
	puts "Usage1: $::prog \[options\] <family\[,family,...\]> \[-|testfile...\] \[gen_job_xml options\]"
	puts ""
	puts "Example 1: $::prog RHEL-7.3 nfs.list"
	puts "Example 2: lstest /some/path/case | $::prog RHEL-6.6 --netqe-nic-driver=tg3 --netqe-nic-num=2"
	puts "Example 3: lstest ./pnfs/blklayout | $::prog runtest Fedora-22,RHEL-7.2,RHEL-7.2 "
	puts "Example 4: $::prog RHEL-7.4 --arch=x86_64 --kdump --nvr=upstream # reserve a host with upstream kernel"
	puts ""
	if {$detail != "n"} {
		getUsage $::OptionList
	} else {
		puts "* try '$::prog -h|less' to get more detail info about options"
	}
}
proc Usage_bkr_reserve {{detail n}} {
	puts "Usage0: $::prog \[-n\] <distro\[,distro,...\]> \[gen_job_xml options\] "
	puts "Example: $::prog RHEL-6.6 --arch=x86_64 --kdump --nvr=kernel-2.6.32-570.el6"
	puts ""
	if {$detail != "n"} {
		getUsage $::OptionList
	} else {
		puts "* try '$::prog -h|less' to get more detail info about options"
	}
}
proc istty {{chann stdin}} {
	dict exists [fconfigure $chann] -mode
}

if [info exist Opt(help)] {
	if {$prog == "bkr-reservesys"} {
		Usage_bkr_reserve detail
	} else {
		Usage detail
	}
	exit 0
}
if {[llength $Args] < 1 && ![info exist Opt(distro)]} {
	if {$prog == "bkr-reservesys"} {
		Usage_bkr_reserve
	} else {
		Usage
	}
	exit 1
}

set SubcmdOpt $ForwardOpt
if [info exist Opt(d)] {
	puts "\[$prog\]: SubcmdOpt{$SubcmdOpt}"
}

set TestArgList {}

set Distro [lindex $Args 0]
if [info exist Opt(distro)] {
	set Distro $Opt(distro)
	set TestArgList [lrange $Args 0 end]
} else {
	set TestArgList [lrange $Args 1 end]
}

#If Distro is a errata name, process it.
if [regexp -- {^RH[A-Z]{2}-[0-9]{4}:[0-9]+} $Distro] {
	lassign [exec errata2distro_and_pkg $Distro] Distro pkgBuild
	set pkgOpt {--install}
	if [regexp -- {^kernel-} $pkgBuild] {set pkgOpt {--nvr}}
	lappend SubcmdOpt $pkgOpt=$pkgBuild
}

#If Distro is short format
set Distro [expandDistro $Distro]

# Get the test list
set _TestList {}
set TestList {}
if [info exist Opt(task)] { set _TestList [list $Opt(task)] }
set TestListFile {}
if {[llength $TestArgList]==0 && ![istty stdin]} {lappend TestArgList -}
if {[llength $TestArgList]==0 && $_TestList == {}} {
	if {$prog != "bkr-reservesys"} {
		puts "\[$prog\]: *Remind*: No test specified, will reserve host($Distro) for you" }
	lappend _TestList "/distribution/reservesys: {attr: {pkg: distrbution, time: 12h, ssched: no, type: Functioal}}"
} else {
	if {$prog == "bkr-reservesys"} {
		lappend _TestList "/distribution/reservesys: {attr: {pkg: distrbution, time: 12h, ssched: no, type: Functioal}}"
	} else {
		foreach f $TestArgList {
			if {$f in "-"} {
				set fp stdin
				while {-1 != [gets $fp line]} {
					lappend _TestList $line
				}
			} elseif [file isfile $f] {
				set TestListFile $f
				if {![catch {set fp [open $f]} err]} {
					while {-1 != [gets $fp line]} {
						lappend _TestList $line
					}
				}
			} elseif [file isdirectory $f] {
				puts stderr "{*Warn*} '$f' is a directory. please use 'lstest $f | $prog <arg> \[opts\]'"
			} else {
				puts stderr "{*Warn*} file '$f' not exist."
			}
		}
	}
}

# test filters
foreach test $_TestList {
	#filter: skip unexpected stuff
	set test [string trim $test]
	if {[regexp -- {^#} $test] == 1} continue
	if {$test == "" || $test == "./"} continue
	regsub -line {^-  *} $test {} test

	set tdict [lindex [::yaml::yaml2dict $test] 1]

	if [dict exist $tdict attr disable] {
		if {[dict get $tdict attr disable] ni {no 0}} continue
	}

	#filter: check distro blacklist
	if [dict exist $tdict attr distronotin] {
		set match_black 0
		set blacklist [dict get $tdict attr distronotin]
		foreach pattern {*}$blacklist {
			if [regexp $pattern [string map {family "RHEL-"} $Distro]] {
				set match_black 1
				break
			}
		}
		if {$match_black == 1} {
			puts stderr "{Filter} match blacklist {$blacklist}: $test"
			continue
		}
	}

	#filter: check distro whitelist
	if [dict exist $tdict attr distroin] {
		set match_white 0
		set whitelist [dict get $tdict attr distroin]
		foreach pattern {*}$whitelist {
			if [regexp $pattern [string map {family "RHEL-"} $Distro]] {
				set match_white 1
			}
		}
		if {$match_white == 0} {
			puts stderr "{Filter} not match whitelist {$whitelist}: $test"
			continue
		}
	}

	#filter: check arch blacklist and whitelist
	set _arch x86_64
	if {[dict exist $tdict setup] || $SubcmdOpt != ""} {
		set _setup {}
		if [dict exist $tdict setup] {
			set _setup [dict get $tdict setup]
		}
		regexp {.*arch=([^ ]+)} "$_setup $SubcmdOpt" _ignore _arch
	}

	set blacklist {}
	if [dict exist $tdict attr archnotin] {set blacklist [dict get $tdict attr archnotin]}
	if [dict exist $tdict attr noarch] {lappend blacklist [dict get $tdict attr noarch]}
	if {$blacklist != ""} {
		set match_black 0
		foreach pattern {*}$blacklist {
			if [regexp $pattern $_arch] {
				set match_black 1
				break
			}
		}
		if {$match_black == 1} {
			puts stderr "{Filter} match blacklist {$blacklist}: $test"
			continue
		}
	}

	set whitelist {}
	if [dict exist $tdict attr archin] {set whitelist [dict get $tdict attr archin]}
	if [dict exist $tdict attr arch] {lappend whitelist [dict get $tdict attr arch]}
	if {$whitelist != ""} {
		set match_white 0
		foreach pattern {*}$whitelist {
			if [regexp $pattern $_arch] {
				set match_white 1
			}
		}
		if {$match_white == 0} {
			puts stderr "{Filter} not match whitelist {$whitelist}: $test"
			continue
		}
	}

	lappend TestList $test
}
unset _TestList

if [info exist Opt(f)] {
	foreach test $TestList {puts $test}
	exit 0
}

# Group the test list
set sschedCnt 0
foreach test $TestList {
	set tdict [lindex [::yaml::yaml2dict $test] 1]

	# get ssched
	set _ssched no
	if [dict exist $tdict attr ssched] {
		set _ssched [dict get $tdict attr ssched]
	}
	if {$_ssched ni {no 0 ""}} {
		set _ssched "yes"
	} else {
		set _ssched "no"
	}
	set ssched "ssched=$_ssched"

	# get setup
	set setup {}
	if [dict exist $tdict setup] {
		set setup [dict get $tdict setup]
	}

	set key [list $ssched $setup]

	if [info exist Opt(alone)] {regsub {ssched=no} $ssched {ssched=yes} ssched}
	if [regexp {ssched=ye} $ssched] {
		lset key 0 "ssched=yes.[incr sschedCnt]"
	}
	lappend TestGroup($key) $test
}

if [info exist Opt(F)] {
	foreach {tkey tvalue} [array get TestGroup] {
		puts "==> $tkey"
		foreach test $tvalue {
			puts "    $test"
		}
	}
	exit
}

if {[array size TestGroup] == 0} {
	puts stderr "{Warn} no valide test. exit"
	exit 1
}

# Gen job xml[s] and submit
set TestCnt 0
set TestSumm {}
set gen_opts {}
set jobN 1
if [info exist Opt(jobn)] {
	regsub {[^0-9]*([1-9][0-9]*).*} $Opt(jobn) {\1} jobN
	if {$jobN == ""} {set jobN 1}
}

if ![regexp -- {--?harness=} $ForwardOpt] {
	if [info exist defaultHarness] {
		set SubcmdOpt [lappend SubcmdOpt "-harness=$defaultHarness"]
	}
}

if [info exist jobOwner] {
	set SubcmdOpt [linsert $SubcmdOpt 0 "-job-owner=$jobOwner"]
}
if [info exist hostRequireAlias] {
	if ![regexp -- {.*-(opt|hr)-alias-file=.*} $SubcmdOpt] {
		set SubcmdOpt [linsert $SubcmdOpt 0 "-opt-alias-file=$hostRequireAlias"]
	}
}

if [info exist Opt(merge)] {
	set xmlf_merged "job_merged.[clock format [clock seconds] -format %Y%m%d_%H%M].[expr {int(rand()*10000)}].xml"
	lappend SubcmdOpt {-recipe}
}

foreach {tkey tvalue} [array get TestGroup] {
	set testGset $tkey
	set testList $tvalue
	set wbComment {}
	if [info exist Opt(wb-comment)] { set wbComment $Opt(wb-comment) }
	if {$TestListFile != ""} { lappend wbComment "$TestListFile" }

	set wbFormat {[%T] [%P@%D %H:%N] %C%S/%s %G %O}
	if [info exist WB_FORMAT] { set wbFormat $WB_FORMAT }
	if [info exist Opt(wb-format)] { set wbFormat $Opt(wb-format) }

	set gset {*}[lrange $testGset 1 end]
	set WB [genWhiteboard $Distro "$testGset $SubcmdOpt" $testList "$wbFormat" $wbComment]
	if {[llength $testList] == 1} {
		set test [lindex $testList 0]
		set tdict [lindex [::yaml::yaml2dict $test] 1]
		if [dict exist $tdict param] {
			append WB "[dict get $tdict param]"
		}
	}
	if {[string length $SubcmdOpt]>0} {
		set _opts $SubcmdOpt
		if [regexp -- {.*-(opt|hr)-alias-file=.*} $_opts] {
			regsub -all -- {--*(opt|hr)-alias-file=[^ ]+ *} $_opts {} _opts
		}
		if {[info exist Opt(kdump)] && $Opt(kdump) != ""} {
			regsub -all {kdump=[^ ]+} $_opts {kdump=*} _opts
		}
		regsub -all "%O" $WB "{$_opts}" WB
	} else {
		regsub -all "%O" $WB "" WB
	}

	set jobinfo job_[regsub -all {[^-?,=_a-zA-Z0-9]} $WB {_}]; # substitute special characters
	set jobinfo [regsub -all {_+} $jobinfo {_}];		   # merge duplicate underlines
	set xmlf [string range $jobinfo 0 128].[expr {int(rand()*10000)}].xml; # limit filename length

	set testDistro $Distro
	if [regexp -- {--?distro=} $gset] {
		set testDistro [regsub {.*--?distro=([^ ]+).*} $gset {\1}]
		set gset [regsub -- {--?distro=([^ ]+)} $gset {}]
		set gset [regsub -all -- {--?nvr=([^ ]+)} $gset {}]
		set testDistro [expandDistro $testDistro]
	}
	if {![catch {set fp \
	  [open "|gen_job_xml -distro=$testDistro -F - {-wb=$WB} $gset $SubcmdOpt >$xmlf 2>@stderr" w]} err]} {
		foreach t $testList { puts $fp "$t" }
		catch {close $fp} err

		puts "\[$prog\]: Test require: {$gset}"
		puts "\[$prog\]: Generate job XML ==> '$xmlf'"

		if [info exist xmlf_merged] {
			exec sed -n {/retention_tag/,/\/notify/p} $xmlf > ${xmlf_merged}.head
			exec sed -n {/recipeSet/,/\/recipeSet/p} $xmlf >> ${xmlf_merged}.body
			exec sed -n {/\/job/,/$/p} $xmlf > ${xmlf_merged}.tail

			file delete $xmlf
		} else {
			if ![info exist Opt(dryrun)] {
				for {set i 0}  {$i < $jobN} {incr i} {
					set status [catch {exec bkr job-submit $xmlf} result]
					puts "$result"
				}
				file delete $xmlf
			} elseif {$Opt(dryrun) != ""} {
				puts [exec cat $xmlf]
				file delete $xmlf
			}
		}
		puts ""
	} else {
		puts "\[$prog\]: Error: fail to write $xmlf\n\n$err"
	}
}

if [info exist xmlf_merged] {
	puts "\[$prog\]: Merged all recipeSets to '$xmlf_merged'"
	set XML [exec cat ${xmlf_merged}.head ${xmlf_merged}.body ${xmlf_merged}.tail]
	file delete ${xmlf_merged}.head
	file delete ${xmlf_merged}.body
	file delete ${xmlf_merged}.tail

	if [info exist TestDir] {set TestList "$TestDir"}
	lassign [genWhiteboard $Distro {merged} $TestList ""] WB tmp
	regsub {<!--(<job .*?>)-->} $XML {\1} XML
	regsub -all {[\&\\]} $WB {\\&} NWB
	if ![regexp -- {--wb=} $ForwardOpt] {
		regsub {<!--<whiteboard>.*?</whiteboard>-->} $XML "<whiteboard>$NWB</whiteboard>" XML
	} else {
		regsub {<!--(<whiteboard>.*?</whiteboard>)-->} $XML {\1} XML
	}
	regsub {<!--(<notify>)} $XML {\1} XML
	regsub {(</notify>)-->} $XML {\1} XML
	regsub -linestop {<!--(</job>)-->$} $XML {\1} XML

	set fp [open $xmlf_merged w]
	puts $fp $XML
	close $fp

	if ![info exist Opt(dryrun)] {
		for {set i 0}  {$i < $jobN} {incr i} {
			set status [catch {exec bkr job-submit $xmlf_merged} result]
			puts "$result"
		}
		file delete $xmlf_merged
	} elseif {$Opt(dryrun) != ""} {
		puts [exec cat $xmlf_merged]
		file delete $xmlf_merged
	}
	#file delete $xmlf_merged
}
