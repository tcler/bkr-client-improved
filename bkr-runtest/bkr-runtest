#!/usr/bin/expect
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

# Author: jiyin@redhat.com
# A beaker client tool, Read testlist from file/stdin(generated by lstest), and
#   call gen_job_xml generate xml files and submit them to beaker server.

lappend ::auto_path $::env(HOME)/lib /usr/local/lib /usr/lib64 /usr/lib
package require getOpt 3.0
package require runtestlib 1.1
namespace import ::getOpt::* ::runtestlib::*

trap {send_user "Got SIGPIPE"; exit} SIGPIPE

source $::runtestConf
if [file exists $::runtestConfPrivate] { source $::runtestConfPrivate }

# global var
set prog [file tail $argv0]
array set Opt {}
array set InvalidOpt {}
set Args [list]
set ForwardOpt {}
set OptionList {
  "  Base options:" {
	{help h}   {arg n	help {Print this usage}}
	{host}	   {arg m	help {restraint standalone mode, if host not reachable create local VM Guest}}
	{dryrun n} {arg o	help {-ntest.xml Just generate XML file(s), not submit job to beaker}}
	{jobn}     {arg y	help {--jobn=N submit job N times}}
	{merge m}  {arg n	help {Merge all recipeSets in one job XML}}
	alone      {arg n	help {Submit all tests separately, one case one recipe}}
	d          {arg n	help {debug mode}}
	wb-format  {arg y	help {Customize whiteboard, default WB_FORMAT in see /etc/bkr-client-improved/bkr-runtest.conf}}
	wb-comment {arg y	help {Add customer string in the default whiteboard}}
	f          {arg n       help {just do dynamic filter and output test list}}
	F          {arg n       help {output test groups and exit} hide yes}
	task       {arg m	help {Include named task in job, can use multiple times}}
	distro     {arg y	help {Use named distro for job}}
	{prettyxml pretty-xml}  {arg n help {do nothing, just for compat other workflow}}
  }
}
source /usr/share/bkr-client-improved/common-options.tcl
lappend OptionList {*}[string map {"\{arg " "\{forward y arg "} $CommonOptionList]

# _parse_ argument
getOptions $OptionList $::argv Opt InvalidOpt Args ForwardOpt
if [info exist Opt(d)] {
	puts "\[$prog\] Arguments:{$Args}"
	puts "\[$prog\] ForwardOpt{$ForwardOpt}"
	parray InvalidOpt
	parray Opt
}
if {[array size InvalidOpt] > 0} {
	puts stderr "{Error} got invalide option\[s\]:"
	foreach {opt value} [array get InvalidOpt] {
		puts stderr "  $opt -> $value"
	}
	exit 1
}

# Usage
proc Usage {{detail n}} {
	puts "Usage0: $::prog \[options\] <distro\[,distro,...\]> \[-|testfile...\] \[gen_job_xml options\] "
	puts "Usage1: $::prog \[options\] <family\[,family,...\]> \[-|testfile...\] \[gen_job_xml options\]"
	puts ""
	puts "Example 1: $::prog RHEL-7.3 nfs.list"
	puts "Example 2: lstest /some/path/case | $::prog RHEL-6.6 --netqe-nic-driver=tg3 --netqe-nic-num=2"
	puts "Example 3: lstest ./pnfs/blklayout | $::prog Fedora-22,RHEL-7.2,RHEL-7.2 "
	puts "Example 4: $::prog family7 --arch=x86_64 --kdump -B=lstk # reserve a host with latest RHEL-7 and latest kernel-*.el7"
	puts "Example 5: $::prog family8.2 --arch=x86_64 --kdump -B=upk # reserve a host with upstream kernel"
	puts ""
	if {$detail != "n"} {
		getUsage $::OptionList
	} else {
		puts "* try '$::prog -h|less' to get more detail info about options"
	}
}
proc Usage_bkr_reserve {{detail n}} {
	puts "Usage0: $::prog \[-n\] <distro\[,distro,...\]> \[gen_job_xml options\] "
	puts "Example: $::prog RHEL-6.6 --arch=x86_64 --kdump --nvr=kernel-2.6.32-570.el6"
	puts ""
	if {$detail != "n"} {
		getUsage $::OptionList
	} else {
		puts "* try '$::prog -h|less' to get more detail info about options"
	}
}
proc istty {{chann stdin}} {
	dict exists [fconfigure $chann] -mode
}

if [info exist Opt(help)] {
	if {$prog == "bkr-reservesys"} {
		Usage_bkr_reserve detail
	} else {
		Usage detail
	}
	exit 0
}
if {[llength $Args] < 1 && ![info exist Opt(distro)]} {
	if {$prog == "bkr-reservesys"} {
		Usage_bkr_reserve
	} else {
		Usage
	}
	exit 1
}

set SubcmdOpt $ForwardOpt
if [info exist Opt(d)] {
	puts stderr "\[$prog\] SubcmdOpt{$SubcmdOpt}"
}

set TestArgList {}

set Distro [lindex $Args 0]
if [info exist Opt(distro)] {
	set Distro $Opt(distro)
	set TestArgList [lrange $Args 0 end]
} else {
	set TestArgList [lrange $Args 1 end]
}

#If Distro is a errata name, process it.
if [regexp -- {^RH[A-Z]{2}-[0-9]{4}:[0-9]+} $Distro] {
	lassign [exec errata2distro_and_pkg $Distro] Distro pkgBuild
	set pkgOpt {--install}
	if [regexp -- {^kernel-} $pkgBuild] {set pkgOpt {--nvr}}
	lappend SubcmdOpt $pkgOpt=$pkgBuild
}

#If Distro is short format
set Distro [expandDistro $Distro]
if {$Distro == ""} {
	puts stderr "\[$prog\] Err: distro value is emtpy, please use a valid value. or 's' for restraint Standalone mode"
	exit 1
}

# Get the test list
set _TestList {}
set TestList {}
if [info exist Opt(task)] {
	lappend _TestList {*}$Opt(task)
}
set TestListFile {}
if {[llength $TestArgList]==0 && ![istty stdin]} {lappend TestArgList -}
if {[llength $TestArgList]==0 && $_TestList == {}} {
	if {$prog != "bkr-reservesys"} {
		puts stderr "\[$prog\] *Remind*: No test specified, will reserve host($Distro) for you"
	}
	if ![regexp -- {--reserve} $ForwardOpt] {
		lappend _TestList {/distribution/reservesys: {attr: {pkg: distribution, time: 12h, ssched: no, type: Functioal}}}
	} else {
		lappend _TestList {/distribution/utils/dummy: {attr: {pkg: distribution}}}
	}
} else {
	if {$prog == "bkr-reservesys"} {
		if ![regexp -- {--reserve} $ForwardOpt] {
			lappend _TestList {/distribution/reservesys: {attr: {pkg: distribution, time: 12h, ssched: no, type: Functioal}}}
		} else {
			lappend _TestList {/distribution/utils/dummy: {attr: {pkg: distribution}}}
		}
	} else {
		foreach f $TestArgList {
			if {$f in "-"} {
				set fp stdin
				while {-1 != [gets $fp line]} {
					lappend _TestList $line
				}
			} elseif [file isfile $f] {
				set TestListFile $f
				if {![catch {set fp [open $f]} err]} {
					while {-1 != [gets $fp line]} {
						lappend _TestList $line
					}
				}
			} elseif [file isdirectory $f] {
				puts stderr "{*Warn*} '$f' is a directory. please use 'lstest $f | $prog <arg> \[opts\]'"
			} else {
				puts stderr "{*Warn*} file '$f' not exist."
			}
		}
	}
}

# test filters
foreach test $_TestList {
	if [string match "{*}" $test] { set test {*}$test }
	regsub -line {^-} $test {} test
	set test [string trim $test]
	if [regexp {^/[^ ]+$} $test] { set test "${test}: {}" }
	if [regexp {^/[^ ]+ ([^= \}]+=.*)+$} $test] {
		set tname [lindex $test 0]
		set paramlist {}
		foreach param [lrange $test 1 end] {
			append paramlist " ,\"$param\""
		}
		set test "${tname}: {param: \[[string range $paramlist 2 end]\]}"
	}
	if {$test in {dummy dumy dum}} { set test "/distribution/utils/dummy: {}" }

	if {[exec yq {.[].attr.disable} << $test] ni {no 0 null}} continue

	#filter: check distro blacklist
	set blacklist [exec yq {.[].attr.distronotin} << $test]
	if {$blacklist != "null"} {
		set match_black 0
		foreach pattern {*}$blacklist {
			if [regexp $pattern [string map {family "RHEL-"} $Distro]] {
				set match_black 1
				break
			}
		}
		if {$match_black == 1} {
			puts stderr "{Filter} match blacklist {$blacklist}: $test"
			continue
		}
	}

	#filter: check distro whitelist
	set whitelist [exec yq {.[].attr.distroin} << $test]
	if {$whitelist != "null"} {
		set match_white 0
		foreach pattern {*}$whitelist {
			if [regexp $pattern [string map {family "RHEL-"} $Distro]] {
				set match_white 1
			}
		}
		if {$match_white == 0} {
			puts stderr "{Filter} not match whitelist {$whitelist}: $test"
			continue
		}
	}

	#filter: check arch blacklist and whitelist
	set _arch x86_64
	set _setup [split [exec yq {.[].setup.[]} << $test] "\n"]
	if {$_setup != "" || $SubcmdOpt != ""} {
		regexp {.*arch=([^ ]+)} "$_setup $SubcmdOpt" _ignore _arch
	}

	set blacklist {}
	set arch_blacklist [string map {"null" "" "\n" " "} [exec yq {.[].attr|(.archnotin,.noarch)} << $test]]
	if {[string trim $arch_blacklist] != ""} {set blacklist [list {*}$arch_blacklist]}
	if {$blacklist != ""} {
		set match_black 0
		foreach pattern {*}$blacklist {
			if [regexp $pattern $_arch] {
				set match_black 1
				break
			}
		}
		if {$match_black == 1} {
			puts stderr "{Filter} match blacklist {$blacklist}: $test"
			continue
		}
	}

	set whitelist {}
	set arch_whitelist [string map {"null" "" "\n" " "} [exec yq {.[].attr|(.archin,.arch)} << $test]]
	if {[string trim $arch_whitelist] != ""} {set whitelist [list {*}$arch_whitelist]}
	if {$whitelist != ""} {
		set match_white 0
		foreach pattern {*}$whitelist {
			if [regexp $pattern $_arch] {
				set match_white 1
			}
		}
		if {$match_white == 0} {
			puts stderr "{Filter} not match whitelist {$whitelist}: $test"
			continue
		}
	}

	lappend TestList $test
}
unset _TestList

if [info exist Opt(f)] {
	foreach test $TestList {puts $test}
	exit 0
}

# Group the test list
set sschedCnt 0
foreach test $TestList {
	# get ssched
	set _ssched [exec yq {.[].attr.ssched} << $test]
	if {$_ssched ni {"null" no 0 ""}} {
		set _ssched "yes"
	} else {
		set _ssched "no"
	}
	set ssched "ssched=$_ssched"

	# get setup
	set setup [split [exec yq {.[].setup.[]} << $test] "\n"]
	set key [list $ssched $setup]

	if [info exist Opt(alone)] {regsub {ssched=no} $ssched {ssched=yes} ssched}
	if [regexp {ssched=ye} $ssched] {
		lset key 0 "ssched=yes.[incr sschedCnt]"
	}
	lappend TestGroup($key) $test
}

if [info exist Opt(F)] {
	foreach {tkey tvalue} [array get TestGroup] {
		puts "==> $tkey"
		foreach test $tvalue {
			puts "    $test"
		}
	}
	exit
}

if {[array size TestGroup] == 0} {
	puts stderr "{Warn} no valide test. exit"
	exit 1
}

# Gen job xml[s] and submit
set TestCnt 0
set TestSumm {}
set gen_opts {}
set jobN 1
if [info exist Opt(jobn)] {
	regsub {[^0-9]*([1-9][0-9]*).*} $Opt(jobn) {\1} jobN
	if {$jobN == ""} {set jobN 1}
}

if ![regexp -- {--?harness=} $ForwardOpt] {
	if [info exist Harness] {
		set SubcmdOpt [lappend SubcmdOpt "-harness=$Harness"]
	}
}

if [info exist jobOwner] {
	set SubcmdOpt [linsert $SubcmdOpt 0 "-job-owner=$jobOwner"]
}

if [info exist groupOwner] {
	set SubcmdOpt [linsert $SubcmdOpt 0 "-group-owner=$groupOwner"]
}

if [info exist hostRequireAlias] {
	if ![regexp -- {.*-(opt|hr)-alias-file=.*} $SubcmdOpt] {
		set SubcmdOpt [linsert $SubcmdOpt 0 "-opt-alias-file=$hostRequireAlias"]
	}
}

if {[array size TestGroup] > 1} {
	if [info exist Opt(merge)] {
		set xmlf_merged "job_merged.[clock format [clock seconds] -format %Y%m%d_%H%M].[expr {int(rand()*10000)}].xml"
		lappend SubcmdOpt {-recipe}
	}
}

set loop 0
foreach {tkey tvalue} [array get TestGroup] {
	set testGset $tkey
	set testList $tvalue
	set wbComment {}
	if [info exist Opt(wb-comment)] { set wbComment $Opt(wb-comment) }
	if {$TestListFile != ""} { lappend wbComment "$TestListFile" }

	set wbFormat {[%T] [%P@%D %H:%N] %C%S/%s %G %O}
	if [info exist WB_FORMAT] { set wbFormat $WB_FORMAT }
	if [info exist Opt(wb-format)] { set wbFormat $Opt(wb-format) }

	set gset {*}[lrange $testGset 1 end]
	set WB [genWhiteboard $Distro "$testGset $SubcmdOpt" $testList "$wbFormat" $wbComment]
	if {[llength $testList] == 1} {
		set test [lindex $testList 0]
		set _param [split [exec yq {.[].param.[]} << $test] "\n"]
		if {$_param != ""} {
			append WB "$_param"
		}
	}
	if {[string length $SubcmdOpt]>0} {
		set _opts $SubcmdOpt
		if [regexp -- {.*-(opt|hr)-alias-file=.*} $_opts] {
			regsub -all -- {--*(opt|hr)-alias-file=[^ ]+ *} $_opts {} _opts
		}
		if {[info exist Opt(kdump)] && $Opt(kdump) != ""} {
			regsub -all {kdump=[^ ]+} $_opts {kdump=*} _opts
		}
		regsub -all "%O" $WB "{$_opts}" WB
	} else {
		regsub -all "%O" $WB "" WB
	}

	set WB [regsub -all -- {--keepchanges} $WB {fetch-opts=keepchanges}]
	set jobinfo job_[regsub -all {[^-?,=_a-zA-Z0-9]} $WB {_}]; # substitute special characters
	set jobinfo [regsub -all {_+} $jobinfo {_}];		   # merge duplicate underlines
	set xmlf [string range $jobinfo 0 128].[expr {int(rand()*10000)}].xml; # limit filename length
	if {[info exist Opt(dryrun)] && $Opt(dryrun) ni {"" "n" "-"}} {
		set xmlf [string map {.xml ""} $Opt(dryrun)]
		if {$loop > 0} {append xmlf "-[pid]-$loop"}
		append xmlf .xml
	}

	set testDistro $Distro
	if [regexp -- {--?distro=} $gset] {
		set testDistro [regsub {.*--?distro=([^ ]+).*} $gset {\1}]
		set gset [regsub -- {--?distro=([^ ]+)} $gset {}]
		set gset [regsub -all -- {--?nvr=([^ ]+)} $gset {}]
		set testDistro [expandDistro $testDistro]
	}

	set hostOpt {}
	set hostParamOpt {}
	if {[info exist Opt(host)]} {
		foreach e $Opt(host) {lappend hostlist {*}[split $e ", "]}
		set xmlf "job-[join $hostlist ,].xml"
		set testDistro s
		set i 0
		set hostOpt [lmap h $hostlist {incr i; set _ "--host=$i=root@$h"}]
		if [regexp -- {topo=singleHost} $gset] {
			set hostOpt [lindex $hostOpt 0]
			set xmlf "job-[lindex $hostlist 0].xml"
		} elseif [regexp -- {topo=multiHost} $gset] {
			set SC [regsub {.*topo=multiHost.([0-9]+).([0-9]+).*} $gset {\1 \2}]
			lassign $SC ServerN ClientN
			set HostN [expr {$ServerN + $ClientN}]
			puts "{debug} ServerN=$ServerN, ClientN=$ClientN, HostN=$HostN"
			if {$HostN > [llength $hostlist]} {
				puts "{error} the job need $HostN hosts, but only got [llength $hostlist]: $hostlist"
				exit 2
			} elseif {$HostN < [llength $hostlist]} {
				set xmlf "job-[join [lindex $hostlist 0 [expr ${HostN}-1]] ,].xml"
			}
			set hostOpt [lrange $hostOpt 0 [expr ${HostN}-1]]
			if {$ServerN > 0} { lappend hostParamOpt "--param=SERVERS=[lrange $hostlist 0 [expr ${ServerN}-1]]" }
			if {$ClientN > 0} { lappend hostParamOpt "--param=CLIENTS=[lrange $hostlist $ServerN [expr ${HostN}-1]]" }
			if {$HostN > 0} { lappend hostParamOpt "--param=RSTRNT_STANDALONE=yes" }
		}
	}
	if {![catch {set fp \
	  [open "|gen_job_xml -distro=$testDistro -F - {-wb=$WB} $gset $SubcmdOpt $hostParamOpt >$xmlf 2>@stderr" w]} err]} {
		foreach t $testList { puts $fp "$t" }
		catch {close $fp} err

		puts stderr "\[$prog\] Test require: {$gset}"
		puts stderr "\[$prog\] Generate job XML ==> '$xmlf'"

		if [info exist xmlf_merged] {
			exec sed -n {/retention_tag/,/\/notify/p} $xmlf > ${xmlf_merged}.head
			exec sed -n {/recipeSet/,/\/recipeSet/p} $xmlf >> ${xmlf_merged}.body
			exec sed -n {/\/job/,/$/p} $xmlf > ${xmlf_merged}.tail

			file delete $xmlf
		} else {
			if {![info exist Opt(dryrun)]} {
				if ![info exist Opt(host)] {
					for {set i 0}  {$i < $jobN} {incr i} {
						set status [catch {exec bkr job-submit $xmlf} result]
						puts "$result"
					}
				} else {
					lmap h $hostlist {exec sed -i /$h/d $env(HOME)/.ssh/known_hosts >@stdout 2>@stderr}
					lmap h $hostlist {exec ssh root@$h {pkill rstrnt-sync; rm -rf /tmp/testmark /var/lib/restraint/rstrnt_events; pstree -pA "$(ps axf|awk '/bash.-l..usr.share.restrain[t]/{print $1}')" | grep -o '([0-9]\+)' | sed 's/[()]//g' | xargs kill -9 2>/dev/null||:} 2> /dev/null}
					puts "{debug} restraint -v --timeout 30 --job $xmlf $hostOpt"
					exec bash -c "restraint -v --timeout 30 --job $xmlf $hostOpt || :" >@stdout 2>@stderr
				}
				file delete $xmlf
			} elseif {$Opt(dryrun) in {"" "n"}} {
				puts [exec cat $xmlf]
				file delete $xmlf
			}
		}
		puts ""
	} else {
		puts stderr "\[$prog\] Err: fail to write $xmlf\n\n$err"
	}
	incr loop
}

if [info exist xmlf_merged] {
	puts stderr "\[$prog\] Merged all recipeSets to '$xmlf_merged'"
	set XML [exec cat ${xmlf_merged}.head ${xmlf_merged}.body ${xmlf_merged}.tail]
	file delete ${xmlf_merged}.head
	file delete ${xmlf_merged}.body
	file delete ${xmlf_merged}.tail

	if [info exist TestDir] {set TestList "$TestDir"}
	lassign [genWhiteboard $Distro {merged} $TestList ""] WB tmp
	regsub {<!--(<job .*?>)-->} $XML {\1} XML
	regsub -all {[\&\\]} $WB {\\&} NWB
	if ![regexp -- {--wb=} $ForwardOpt] {
		regsub {<!--<whiteboard>.*?</whiteboard>-->} $XML "<whiteboard>$NWB</whiteboard>" XML
	} else {
		regsub {<!--(<whiteboard>.*?</whiteboard>)-->} $XML {\1} XML
	}
	regsub {<!--(<notify>)} $XML {\1} XML
	regsub {(</notify>)-->} $XML {\1} XML
	regsub -linestop {<!--(</job>)-->$} $XML {\1} XML

	set fp [open $xmlf_merged w]
	puts $fp $XML
	close $fp

	if ![info exist Opt(dryrun)] {
		for {set i 0}  {$i < $jobN} {incr i} {
			set status [catch {exec bkr job-submit $xmlf_merged} result]
			puts "$result"
		}
		file delete $xmlf_merged
	} elseif {$Opt(dryrun) != ""} {
		puts [exec cat $xmlf_merged]
		file delete $xmlf_merged
	}
	#file delete $xmlf_merged
}
