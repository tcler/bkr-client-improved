#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

# Author: jiyin@redhat.com
# Like but better than "bkr workflow-xxx --dryrun", more functional and flexible
# gen_job_xml --help for detail

lappend ::auto_path $::env(HOME)/lib /usr/local/lib /usr/lib64 /usr/lib
package require uri
package require json
package require xmlgen
package require getOpt 3.0
package require runtestlib 1.1
namespace import ::xmlgen::* ::getOpt::* ::runtestlib::*

declaretags job whiteboard notify cc
declaretags recipeSet recipe and or not
declaretags distroRequires distro_name distro_family distro_tag distro_variant distro_method distro_arch
declaretags hostRequires hostname arch system_type key_value
declaretags repos repo
declaretags partitions partition
declaretags ks_appends ks_append
declaretags watchdog
declaretags task params param
set dummytask /distribution/utils/dummy
set restraintrepo {}
#set LOOKASIDE_BASE_URL "http://fs-qe.usersys.redhat.com/ftp/pub/lookaside"
set LOOKASIDE_BASE_URL "http://download.devel.redhat.com/qa/rhts/lookaside"
if {[info exists ::env(LOOKASIDE)] && $::env(LOOKASIDE) != ""} {
	set LOOKASIDE_BASE_URL $::env(LOOKASIDE)
}

if {[info commands lmap] == ""} {
	proc lmap args {
		set body [lindex $args end]
		set args [lrange $args 0 end-1]
		set n 0
		set pairs [list]
		foreach {varnames listval} $args {
			set varlist [list]
			foreach varname $varnames {
				upvar 1 $varname var$n
				lappend varlist var$n
				incr n
			}
			lappend pairs $varlist $listval
		}
		set temp [list]
		foreach {*}$pairs {
			lappend temp [uplevel 1 $body]
		}
		set temp
	}
}

proc json2dict {txt} {
  set rc [catch {::json::json2dict $txt} result options]
  if {$rc != 0} {
    #puts stderr "{WARN} JSON ERROR: $result"
    return {}
  }
  return $result
}

proc get_nrestraint_repo {distro} {
	if [regexp -nocase -- {^RHEL-[0-9]+.*} $distro] {
		set osver "[regsub {^(RHEL-[0-9]+).*$} $distro {\1}]"
	}
	if [regexp -nocase -- {^fedora-[0-9]+.*} $distro] {
		set osver "[regsub {^(fedora)-([0-9]+).*$} $distro {\1\2}]"
	}
	return "${::LOOKASIDE_BASE_URL}/beaker-harness-active/[string tolower $osver]"
}

proc arch_suffix {arch} {
	return [string map {x86_64 amd64 aarch64 arm64} $arch]
}

# global var
array set Opt {}
array set InvalidOpt {}
set NotOptions [list]
source $::runtestConf
if [file exists $::runtestConfPrivate] { source $::runtestConfPrivate }
set defaultOSInstaller /distribution/check-install
if {![info exist OSInstaller]} {
	set OSInstaller $defaultOSInstaller
}
if {![info exist defaultSwitch2BootcFromImageModeTask]} {
	set defaultSwitch2BootcFromImageModeTask /network-qe/bootc-beaker/switch-to-rhel
}
if {![info exist defaultSwitch2BootcFromPkgModeTask]} {
	set defaultSwitch2BootcFromPkgModeTask /network-qe/bootc-beaker/switch-pkg-to-image-mode
}
if {![info exist defaultImageTag]} {
	set defaultImageTag {latest-9.6}
}

set OptionList {
  "  Options:" {
	{help h}      {arg n	help {Print this usage}}
	F             {arg m	help {Specify a test list file}}
	opts-macro    {arg y	help {exec the "cmd [arg]" in run time to generate options} hide y}
	distro        {arg y	help {Use named distro for job, same as --dr=distro_name=\$DISTRO}}
  }
}
source /usr/share/bkr-client-improved/common-options.tcl
lappend OptionList {*}$CommonOptionList

proc Usage {{out "stdout"}} {
	puts $out "Usage: $::argv0 --distro=<DISTRO> \[options\]"
	puts $out "Generates a Beaker job XML file, like `bkr workflow-simple`, but have many improvements and unofficial options"
	puts $out "Example:  gen_job_xml --distro RHEL-6.6 --task=/distribution/reservesys --arch=x86_64"
	puts $out "Example:  gen_job_xml --family RedHatEnterpriseLinux7 -F test.list --Brew=kernel-x.y.z-abc.el7 --dbgk\n"
	getUsage $::OptionList $out
}

proc getDefaultNVR {_distro} {
	set reg $_distro
	if [regexp {^RHEL-[0-9]\.[0-9]$} $reg] {
		regsub {RHEL-([0-9]+\.[0-9]+)} $reg {RHEL-./\1} reg
	}

	set _NVR [exec bash -c "distro-compose -p '^kernel-\[0-9]+\[-.0-9]+\.' -d ${reg}$ || :"]
	if [regsub {.*(kernel-[2-6]+[-.0-9]+\.[^.]+).*} $_NVR {\1} _defaultNVR] {
		return $_defaultNVR
	} else {
		return {}
	}
}

proc longestCommonPrefix {paths} {
	set chan [open {|sed -e {$!{N;s/^\(.*\).*\n\1.*$/\1\n\1/;D;}} -e {/^$/d}} r+]
	puts $chan $paths
	flush $chan
	chan close $chan write
	set buf [read $chan]
	close $chan
	return [string trim $buf]
}
proc queryStringToDict {query} {
	set qdict {}
	foreach item [split $query "&"] {
		if {[regexp {^([^=]+)=(.*)$} $item -> key value]} {
			dict set qdict [DecodeURL $key] [DecodeURL $value]
		}
	}
	return $qdict
}
proc DecodeURL {string} {
	# This *is* tricky! The URL encoding of fields is way nastier than you thought!
	set mapped [string map {+ { } \[ "\\\[" \] "\\\]" $ "\\$" \\ "\\\\"} $string]
	encoding convertfrom utf-8 \
		[subst [regsub -all {%([[:xdigit:]]{2})} $string {[format %c 0x\1]}]]
}

# _parse_ argument
set option-alias-path http://pkgs.devel.redhat.com/cgit/tests/kernel/plain/filesystems/Inventory/hostrequire-alias.tcl
set option-alias-path https://gitlab.cee.redhat.com/kernel-qe/kernel/raw/master/filesystems/Inventory/hostrequire-alias.tcl
set bkrurl https://beaker.engineering.redhat.com
set aliasf alias.tcl
set ARGV $::argv
getOptions $OptionList $ARGV Opt InvalidOpt NotOptions

# Defining mutually exclusive option groups
set mutual_exclusive_groups {
	{bootc-direct packages}
	{bootc-direct bootc}
	{bootc-direct Brew}
	{bootc-direct brew}
}

proc check_mutual_exclusive_options {mutual_exclusive_groups} {
	global Opt
	foreach group $mutual_exclusive_groups {
		set count 0
		foreach opt $group {
			if {[info exist Opt($opt)]} {
				incr count
			}
		}
		if {$count > 1} {
			puts stderr "Error: The following options are mutually exclusive: [join $group {, }]"
			exit 1
		}
	}
}

proc check_mutual_exclusive_values {option value_patterns} {
	if {![info exist ::Opt($option)]} {
		return
	}

	set values [split $::Opt($option) ","]
	set found_patterns {}

	foreach pattern $value_patterns {
		foreach value $values {
			if {[string match $pattern $value]} {
				lappend found_patterns $pattern
				break
			}
		}
	}

	if {[llength $found_patterns] > 1} {
		puts stderr "Error: The following values are mutually exclusive within the --$option option: [join $found_patterns {, }]"
		exit 1
	}
}
# check options can't appear at the same time
check_mutual_exclusive_options $mutual_exclusive_groups

# check options's value can't appear at the same time
check_mutual_exclusive_values bootc {fromimg TAGS=*}
check_mutual_exclusive_values bootc {springboard=* TAGS=*}

if {[info exist Opt(opt-alias)] && $Opt(opt-alias) != ""} {
	set alias $Opt(opt-alias)
	if {[info exist Opt(opt-alias-file)] && $Opt(opt-alias-file) != ""} {
		set option-alias-path $Opt(opt-alias-file)
	}
	if [file isfile ${option-alias-path}] {
		set aliasf ${option-alias-path}
	} else {
		exec bash -c "curl -Lks --noproxy '*' ${option-alias-path} -o ${aliasf}"
	}
	source ${aliasf}
	set idx [lindex [lsearch -all -regexp $ARGV {-(opt|hr)-alias(=.*)?$}] end]
	if [regexp -- {.*-(opt|hr)-alias$} [lindex $ARGV $idx]] {set ARGV [lreplace $ARGV $idx+1 $idx+1]}
	set ARGV [lreplace $ARGV $idx $idx]
	set NARGV [linsert $ARGV $idx {*}$Alias($alias)]
	getOptions $OptionList $NARGV Opt InvalidOpt NotOptions

	if ![file isfile ${option-alias-path}] {
		exec rm ${aliasf}
	}
}

proc debug {} {
	puts "NotOptions: $NotOptions"
	parray InvalidOpt
	parray Opt
}

if [info exist Opt(help)] {
	Usage
	exit 0
}

set nrestraint no
if [info exist Opt(nrestraint)] { set nrestraint yes }
if {![info exist Opt(nrestraint-repo)] && [info exist Opt(restraint-repo)]} { set Opt(nrestraint-repo) "$Opt(restraint-repo)" }
if [info exist Opt(nrestraint-repo)] {
	set nrestraint yes
	set restraintrepo "$Opt(nrestraint-repo)"
}

set fetch_test_from_url yes
array set taskFetchUrl {}
set taskname2urlOpts {}
set task-fetch-opts {}
set kpchgs {yes}
set kpchgsParam {}
if [info exist Opt(fetch-url)] {
	foreach _url $Opt(fetch-url) {
		regsub -line {^/+} $_url {} _url
		if {${_url} == "no"} {
			set fetch_test_from_url no
			set taskname2urlOpts "-skiprepo"
			break
		}
		if ![regexp -- {[,@]} ${_url}] {
			append taskname2urlOpts "-repo=${_url}@ "
		} else {
			append taskname2urlOpts "-repo=[string map {, @} $_url] "
		}
	}
}

if [info exist Opt(fetch-opts)] {
	set task-fetch-opts " $Opt(fetch-opts)"
	set task-fetch-opts [regsub {abort[^ ,]*,?} ${task-fetch-opts} {/}]
	if [string match {*keepchanges=no*} ${task-fetch-opts}] {
		set kpchgs "no"
	}
}
if [info exist Opt(offkeepchanges)] {
	set kpchgs "no"
	unset -nocomplain Opt(keepchanges)
}
if [info exist Opt(keepchanges)] {
	set kpchgs {yes}
	if ![string match {*keepchanges*} ${task-fetch-opts}] {
		append task-fetch-opts " keepchanges"
	}
}
if [info exist Opt(task-fetch-url)] {
	foreach _url $Opt(task-fetch-url) {
		if ![regexp -- {[,@]} ${_url}] {
			append _url "@"
		}
		lassign [split ${_url} {[,@]}] taskname url
		if {$url != ""} {
			set taskname [regsub {^/+} $taskname {/}]
			set url "[regsub {#( |$)} $url {\1}]"
			if ![regexp -- {.*#.*} ${url}] {
				if ![regexp -- { } ${url}] {
					append url "#[regsub {^/*[^/]+/} $taskname {}]"
				} else {
					set url [regsub { } $url "#[regsub {^/*[^/]+/} $taskname {}] "]
				}
			}
			if [regexp -- {.*#\.\.( |$)} ${url}] {
				set url "[regsub {#\.\.} $url [regsub {^/+} "#$taskname" {}]]"
			}
		}
		set taskFetchUrl($taskname) $url
	}
}

proc gettask_uri_and_opts {taskname inuri} {
	set _uri {}
	set _autopath "no"
	if {[info exists ::Opt(autopath)]} { set _autopath "yes" }
	if {$inuri ne ""} {
		set taskname [regsub {^/+} $taskname {/}]
		set inuri "[regsub {#( |$)} $inuri {\1}]"
		if ![regexp -- {.*#.*} ${inuri}] {
			if ![regexp -- { } ${inuri}] {
				append inuri "#[regsub {^/*[^/]+/} $taskname {}]"
			} else {
				set inuri [regsub { } $inuri "#[regsub {^/*[^/]+/} $taskname {}] "]
			}
		}
		if [regexp -- {.*#\.\.( |$)} ${inuri}] {
			set inuri "[regsub {#\.\.} $inuri [regsub {^/+} "#$taskname" {}]]"
		}
		set _uri $inuri
		if [regexp -- {\?path=} ${inuri}] { set _autopath "no" }
	} elseif [info exist ::taskFetchUrl($taskname)] {
		set _uri $::taskFetchUrl($taskname)
	} else {
		set _uri [exec bash -c "taskname2url.py $taskname $::taskname2urlOpts 2>/dev/null || :"]
	}
	if {$_autopath == "yes"} {
		set pathQuery "?path=[regsub {^/*[^/]+/} $taskname {}]"
		set _uri [regsub {\?path=[^#]*} $_uri {}]
		set _uri [regsub {#} $_uri "$pathQuery#"]
	}
	return $_uri
}
proc fetchtag {uri} {
	if {$uri != ""} {
		doTag fetch "url=${uri}" -
	}
}
# default bootc_mode setting, use for initial value.
# values: ''(empty value), no(change from bootc mode), fromImageModeDirect, fromPkgMode, fromimg
set bootc_mode no
# save multiple bootc tags or urls depend on which value on current ROLE
# need initial on bootc or bootc-direct bootcToList {}
#save multiple bootc mode on different machines, value come from bootc_mode
set bootc_mode_list {}
set default-ksf "/etc/beaker/default-ks.cfg"
set PART_MPS ""
set REPOS ""
set ROLE_LIST {}
if [info exist Opt(topo)] {
	if ![regexp -nocase {single} $Opt(topo)] {
		lassign [regsub -all {[^0-9]+} $Opt(topo) " "] Opt(servers) Opt(clients)
		if {$Opt(servers) == ""} {set Opt(servers) 1}
		if {$Opt(clients) == ""} {set Opt(clients) 1}
	}
}
if {[info exist Opt(servers)] && $Opt(servers) != 0} { lappend ROLE_LIST {*}[lrepeat $Opt(servers) SERVERS] }
if {[info exist Opt(clients)] && $Opt(clients) != 0} { lappend ROLE_LIST {*}[lrepeat $Opt(clients) CLIENTS] }
if {[llength $ROLE_LIST] == 0} { set ROLE_LIST STANDALONE }

if {[info exist Opt(bootc-direct)]} {
	if {[string length $Opt(bootc-direct)] == 0} {
		puts stderr "{Error}: a image url is required by option --bootc-direct"
		exit 1
	}
	set bootc_mode fromImageModeDirect
	set default-ksf "/dev/null"
	set bootc_direct_list [split $Opt(bootc-direct) ","]
	set num_machines [llength $ROLE_LIST]
	set num_urls [llength $bootc_direct_list]

	#If there is only one URL, use the same URL for all machines
	if {$num_urls == 1 && $num_machines > 1} {
		set bootc_direct_list [lrepeat $num_machines [lindex $bootc_direct_list 0]]
	} elseif {$num_urls != $num_machines} {
		puts stderr "{Error}: number of bootc-direct URLs ($num_urls) does not match number of machines ($num_machines)"
		exit 1
	}
	set bootc_mode_list [lrepeat $num_machines "fromImageModeDirect"]
	set bootcToList $bootc_direct_list
}

if {[info exist Opt(bootc)]} {

	set bootcparams [split $Opt(bootc) ","]
	lassign [lrepeat 3 ""] ContainerPkgs ContainerBPkgs ContainerScriptUrl

	set has_tags_keyword 0
	foreach bootc_param $Opt(bootc) {
		if {[string match "TAGS=*" $bootc_param]} {
			set has_tags_keyword 1
			break
		}
	}

	# Deal with TAGS situation
	if {$has_tags_keyword} {
		set bootc_mode "fromPkgMode"
		foreach bootc_param $Opt(bootc) {
			if {[string match "TAGS=*" $bootc_param]} {
				#extract context after TAGS
				set tags_str [ string range $bootc_param 5 end]
				#Split tags by comma
				set raw_tags [split $tags_str ","]
				#check raw_tags belong a distro
				foreach tag $raw_tags {
					if {$tag eq "_"} {
						# a special tag means didn't using bootc
						lappend bootc_mode_list "no"
						lappend bootcToList ""
					} elseif {$tag eq ""} {
						lappend bootc_mode_list "fromPkgMode"
						lappend bootcToList "followDistro"
					} elseif {[regexp -- {^(RHEL|latest)} $tag]} {
						lappend bootc_mode_list "fromPkgMode"
						lappend bootcToList "$tag"
					}
				}
				# Check if the number of bootcToList matches the number of machines
				if {[llength $bootcToList] != [llength $ROLE_LIST]} {
					puts stderr "Error: Number of bootc tags ([llength $bootcToList]) does not match number of machines ([llength $ROLE_LIST])"
					exit 1
				}
			}
			foreach cparam $bootcparams {
				if [regexp -- {^(cmdl?|script)url=} $cparam] {
					set ContainerScriptUrl [regsub -expanded {^(cmdl?|script)url=} $cparam {}]
				} elseif {$cparam == "fromimg"} {
					puts stderr "Error: in TAGS scenario currently didn't support with fromimg"
					exit 1
				} elseif [regexp -- {^springboard.*=} $cparam] {
					puts stderr "Error: in TAGS scenario currently didn't support with springboard"
					exit 1
				}
			}
		}
	} else {
		set bootc_mode "fromPkgMode"
		set bootcTo "followDistro"
		foreach cparam $bootcparams {
			if [regexp -- {^(cmdl?|script)url=} $cparam] {
				set ContainerScriptUrl [regsub -expanded {^(cmdl?|script)url=} $cparam {}]
			} elseif {$cparam == "fromimg"} {
				set bootc_mode fromImageMode
				set default-ksf "/etc/beaker/default-bootc-mode-ks.cfg"
			} elseif [regexp -- {^springboard.*=} $cparam] {
				set SpringBoardImageUrl [regsub -expanded {^springboard.*=} $cparam {}]
				if {$SpringBoardImageUrl == "no"} {
					unset SpringBoardImageUrl
				}
			} elseif [regexp -- {^(RHEL|latest)} $cparam] {
				set bootcTo $cparam
			}
		}
		set bootcToList [lrepeat [llength $ROLE_LIST] $bootcTo]
		set bootc_mode_list [lrepeat [llength $ROLE_LIST] $bootc_mode]
	}
}

if {![info exist Opt(priority)]} {
	set  Opt(priority) "Normal"
}

# Initialize the array to store the KS content of each ROLE
array set roleKsfContents {}
array set roleBootcKsAppends {}
set R 0
foreach role ${ROLE_LIST} {
	# The bootc parameters passed to different roles need to be processed separately
	set current_bootcTo ""
	set current_bootc_mode ""
	if {[info exist bootcToList]} {
		set current_bootcTo [lindex $bootcToList $R]
		set current_bootc_mode [lindex $bootc_mode_list $R]
	}

	set role_bootc_ksAppend {}
	if {$current_bootc_mode == "fromPkgMode"} {
		set Switch2BootcTask $defaultSwitch2BootcFromPkgModeTask
		set default-ksf "/dev/null"
		append role_bootc_ksAppend "part /boot --fstype=ext4 --recommended\n"
		append role_bootc_ksAppend "part / --fstype=ext4 --grow\n"
		append role_bootc_ksAppend "part /swap --fstype=ext4 --recommended\n"
	} elseif {$current_bootc_mode == "fromImageMode"} {
		set Switch2BootcTask $defaultSwitch2BootcFromImageModeTask
		set default-ksf "/etc/beaker/default-bootc-mode-ks.cfg"
	} elseif {${current_bootc_mode} == "fromImageModeDirect"} {
		set current_bootc_direct [lindex $bootc_direct_list $R]
		if {$current_bootc_direct != "_"} {
			append role_bootc_ksAppend "ostreecontainer --url $current_bootc_direct\n"
		}
		set default-ksf "/dev/null"
	} else {
		set Switch2BootcTask ""
		set default-ksf "/etc/beaker/default-ks.cfg"
	}

	# read self define ksAppend
	set ksfPath ${default-ksf}
	if {[info exist Opt(ksf)] && $Opt(ksf) != ""} {
		set ksfPath $Opt(ksf)
	}

	set ksfContent {}
	if [file isfile $ksfPath] {
		if {![catch {set fp [open $ksfPath]} err]} {
			set ksfContent [read $fp]
			close $fp
		}
		if {[info exist SpringBoardImageUrl]} {
			regsub -line {\nostreecontainer --url [^\n]*\n} $ksfContent "\nostreecontainer --url $SpringBoardImageUrl\n" ksfContent
		}
	}

	if [info exist Opt(norun)] {
		append ksfContent {
		%post
		_rpath=share/restraint/plugins/task_run.d
		_path_url=${LOOKASIDE_BASE_URL}/bkr-client-improved/$_rpath
		pushd /usr/$_rpath
			curl -Lks -O ${_path_url}/28_exit0
			chmod a+x *
		popd
		%end
		}
		if ![info exist Opt(reserve)] { set Opt(reserve) 356400 }
	}

	# Store the KS content of the current ROLE
	set roleKsfContents($R) $ksfContent
	set roleBootcKsAppends($R) $role_bootc_ksAppend

	set R [ expr $R + 1 ]
}
set R 0

# process --param= option
set GlobalParam {}
if [info exist Opt(param)] { lappend GlobalParam {*}$Opt(param) }
if [info exist Opt(noavc)] { lappend GlobalParam "AVC_ERROR=+no_avc_check" }
if [info exist Opt(task-fetch-url)] { lappend GlobalParam "TASK_URIS=$Opt(task-fetch-url)" }
if [info exist Opt(fetch-url)] { lappend GlobalParam "REPO_URLS=$Opt(fetch-url)" }
# Check the KS content of all ROLEs and set global parameters
set overWriteRpmSet false
set dryRunSet false

for {set i 0} {$i < [llength $ROLE_LIST]} {incr i} {
	set ksfContent $roleKsfContents($i)

	if {!$overWriteRpmSet && [regexp -- {cat .*>.*/27_task_require} $ksfContent]} {
		puts stderr "DEBUG: Found /27_task_require in KS content for role $i, setting OVER_WRITE_RPM"
		lappend GlobalParam "OVER_WRITE_RPM="
		set overWriteRpmSet true
	}

	if {!$dryRunSet && [regexp -- {cat .*>.*/28_exit0} $ksfContent]} {
		puts stderr "DEBUG: Found /28_exit0 in KS content for role $i, setting DRYRUN=yes"
		lappend GlobalParam "DRYRUN=yes"
		set dryRunSet true
	}

	# If both parameters have been set, you can exit the loop early
	if {$overWriteRpmSet && $dryRunSet} {
		puts stderr "DEBUG: Both OVER_WRITE_RPM and DRYRUN set, stopping KS content check"
		break
	}
}
if [info exist Opt(maxtime)] { lappend GlobalParam "KILLTIMEOVERRIDE=$Opt(maxtime)" }

# process --distro= option
set DISTRO_L {}
set FAMILY_L {}
set TAG_L {}
set _ldistro {}
set _lfamily {}
set _ltag {RTT_ACCEPTED}
if [info exist Opt(distro)] {
	if [info exist Opt(distrot)] {
		set _bootc ""
		if {${bootc_mode} ni "no"} { set _bootc "yes" }
		set Opt(distro) [string map "%D $Opt(distro)" [expandDistro $Opt(distrot) ${_bootc}]]
	}
	foreach e $Opt(distro) {lappend _ldistro {*}[split $e ", "]}
	set prev {}
	foreach d $_ldistro {
		if [regexp -- {^RedHatEnterpriseLinux} $d] {
			set d [string map {RedHatEnterpriseLinux "family"} $d]
		}
		if {[string length $d] > 0} {
			lappend DISTRO_L $d
			set prev $d
		} elseif {[string length $prev] > 0} {
			lappend DISTRO_L $prev
		}
	}
}

#Deal with followDistro on bootc
if {[info exist bootcToList]} {
	set new_bootcToList {}
	set distro_index 0
	foreach tag $bootcToList {
		# got the DISTRO of current ROLE
		if {$tag eq "followDistro"} {
			if {$distro_index < [llength $DISTRO_L]} {
				set distro [lindex $DISTRO_L $distro_index]
			} else {
				# If DISTRO_L is not long enough, assign the last distro to reminder servers.
				set distro [lindex $DISTRO_L end]
				puts stderr "{debug}: DISTRO is not long enough tags, assign $distro to reminder servers"
			}
			# Din't support family with bootc
			if {[string match family* $distro]} {
				# If it is in family format, it needs to be converted to a specific distro
				puts stderr "{ERROR}: bootc didn't support with --distro family* please check!!!"
				exit 1
			}
			lappend new_bootcToList $distro
		} else {
			lappend new_bootcToList $tag
		}
		incr distro_index
	}
	set bootcToList $new_bootcToList
}
# For the latest tag, convert to the specific compose ID
if {[info exist bootcToList]} {
	set new_bootcToList {}
	foreach tag $bootcToList {
		if {$tag != ""} {
			puts stderr "{debug}: replace DISTRO with compose-id of current_bootcTo:$tag"
			if {[string match {latest*} $tag]} {
				set cmdl "skopeo inspect --retry-times 16 docker://images.paas.redhat.com/bootc/rhel-bootc:$tag | jq -r '.Labels\[\"redhat.compose-id\"\]'"
				if {[catch {set tag [exec bash -c $cmdl]} error]} {
					puts stderr "Error: failed to get compose-id for tag $tag: $error"
					exit 1
				}
			}
		}
		lappend new_bootcToList $tag
	}
	set bootcToList $new_bootcToList
}

if [info exist Opt(family)] {
	foreach e $Opt(family) {lappend _lfamily {*}[split $e ", "]}
	set prev {}
	foreach family $_lfamily {
		if {[string length $family] > 0} {
			lappend FAMILY_L $family
			set prev $family
		} elseif {[string length $prev] > 0} {
			lappend FAMILY_L $prev
		}
	}
}
if [info exist Opt(tag)] {
	foreach e $Opt(tag) {lappend _ltag {*}[split $e ", "]}
	set prev {}
	foreach t $_ltag {
		if {[string length $t] > 0} {
			lappend TAG_L $t
			set prev $t
		} elseif {[string length $prev] > 0} {
			lappend TAG_L $prev
		}
	}
}

if [info exist Opt(upstream)] {
	set upstreamUrl https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
	set upstreamBranch master
	set upstreamTag HEAD
	if {$Opt(upstream) != ""} {
		lassign [split $Opt(upstream) { @}] url_branch tag
		lassign [split $url_branch "#"] url branch
		if {[string trim $url] != ""} {set upstreamUrl $url}
		if {[string trim $branch] != ""} {set upstreamBranch $branch}
		if {[string trim $tag] != ""} {set upstreamTag $tag}
	}
}

set tasksDesc {}
if [info exist Opt(tasksdesc)] {
	set tasksDesc "$Opt(tasksdesc)"
}

if {[llength $DISTRO_L] == 0 && [llength $FAMILY_L] == 0} {
	puts stderr "Warning: no distro specified, use --distro= or --family= option"
	Usage stderr
	exit 1
}

#fixme: deprecated, remove
if {[regexp -- {RHEL-8|family8} $DISTRO_L] == 1 && [info exist Opt(harness)]} {
	set Opt(harness) rst
	if [info exist Opt(wb)] {
		regsub -line {harness=[[:alnum:]]*} $Opt(wb) {harness=rst} Opt(wb)
	}
}

# process -F or --task= option
set TaskList {}
set TestList {}
if [info exist Opt(task)] { lappend TestList {*}$Opt(task) }
if [info exist Opt(F)] {
	foreach testfile $Opt(F) {
		set fp stdin
		if {$testfile ni "-"} {
			set fp [open $testfile]
		}

		while {-1 != [gets $fp line]} {
			lappend TestList $line
		}

		if {$testfile ni "-"} { close $fp }
	}
}
if {[llength $TestList] == 0} {
	puts stderr "Warning: no task specified, use -F or --task= option"
	Usage stderr
	exit 1
}
foreach T $TestList {
	set test [string trim $T]
	if {[regexp -- {^#} $test] == 1} continue
	if {$test == "" || $test == "./"} continue
	regsub -line {^-  *} $test {} test

	set tname [exec yq {keys|.[0]} << $test]
	set param [split [exec yq {.[].param.[]} << $test] "\n"]

	if {$param != "null"} {
		lappend TaskList [concat $tname $param $GlobalParam]
	} else {
		lappend TaskList [concat $tname $GlobalParam]
	}
}

if {[info exist Opt(watchdog-panic)]} { set WATCHDOG_PANIC $Opt(watchdog-panic) }
if {[info exist Opt(ignore-panic)]} { set WATCHDOG_PANIC "ignore" }

set METHOD "nfs"
if [info exist Opt(method)] {
	set METHOD $Opt(method)
}

set SystemTypeList {}
if [info exist Opt(systype)] {
	foreach e $Opt(systype) {lappend SystemTypeList {*}[split $e ", "]}
}

set VARIANT_L {}
if [info exist Opt(variant)] {
	foreach e $Opt(variant) {lappend VARIANT_L {*}[split $e ", "]}
}

set KVARIANT "up"
if [info exist Opt(dbgk)] { set KVARIANT "debug" }

set MACHINE_L {}
if [info exist Opt(machine)] {
	foreach e $Opt(machine) {lappend MACHINE_L {*}[split $e ", "]}
}

set NVR_L {}
if [info exist Opt(nvr)] {
	foreach e $Opt(nvr) {lappend NVR_L {*}[split $e ", "]}
	if {[llength $DISTRO_L] == 1 && [llength $NVR_L] == 1} {
		set _defaultNVR [getDefaultNVR $DISTRO_L]
		if {$_defaultNVR == $NVR_L} {
			set NVR_L {}
		}
	}
}

set ORMACHINE_L {}
if [info exist Opt(ormachine)] {
	foreach e $Opt(ormachine) {lappend ORMACHINE_L {*}[split $e ", "]}
}

set ARCH_L {auto}
if [info exist Opt(arch)] {
	set ARCH_L {}
	foreach e $Opt(arch) {lappend ARCH_L {*}[split $e ", "]}
}

set FIPS_L {}
if [info exist Opt(fips)] {
	foreach e $Opt(fips) {lappend FIPS_L {*}[split $e ", "]}
}

set recipe_ks_meta {}
set harness restraint

if {$harness in {r re res rest restr restra restrai restrain restraint rst}} {
	set recipe_ks_meta "harness='restraint-rhts beakerlib' redhat_ca_cert"
}

if [info exist Opt(ks-meta)] { append recipe_ks_meta " " {*}$Opt(ks-meta) }
set ksAppend {}

if {[info exist Opt(ks-pkgs)]} {
	append ksAppend "\n%packages --ignoremissing"
	foreach ks $Opt(ks-pkgs) { append ksAppend "\n[string map {" " "\n"} $ks]" }
	append ksAppend "\n%end"
}
if [info exist Opt(ks-append)] { foreach ks $Opt(ks-append) { append ksAppend "\n$ks" } }
if [info exist Opt(ks-post)] {
	append ksAppend "\n%post"
	foreach ks $Opt(ks-post) { append ksAppend "\n$ks" }
	append ksAppend "\n%end"
}
if [info exist Opt(ks-pre)] {
	append ksAppend "\n%pre"
	foreach ks $Opt(ks-pre) { append ksAppend "\n$ks" }
	append ksAppend "\n%end"
}

#https://projects.engineering.redhat.com/browse/BKR-4998
append recipe_ks_meta " disabled_root_access"

# handle network-qe private NIC machines
set netqe_nic_opts {pciid driver model speed match unmatch num}
foreach i $netqe_nic_opts {
	if [info exist Opt(netqe-nic-$i)] {
		set NETQE_NIC_OPTS_DICT($i) [split $Opt(netqe-nic-$i) ", "]
	}
}

set M 0
foreach role $ROLE_LIST {
	# set netqe-nic machine list for different role
	if [info exist NETQE_NIC_OPTS_DICT] {
		# init each params for parse_netqe_nic_info.sh
		foreach i $netqe_nic_opts { set $i {} }

		# get netqe-nic-* options key-val for each role
		foreach key [array names NETQE_NIC_OPTS_DICT] {
			set $key [lindex $NETQE_NIC_OPTS_DICT($key) $M]
			eval set val $$key
			if {$val==""} {set $key [lindex $NETQE_NIC_OPTS_DICT($key) 0]}
		}

		# set default values for parse_netqe_nic_info.sh params
		if {$pciid==""} {set pciid any}
		if {$driver==""} {set driver any}
		if {$model==""} {set model any}
		if {$speed==""} {set speed any}
		if {$match==""} {set match any}
		if {$unmatch ==""} {set unmatch ''}
		if {$num==""} {set num 1}

		# get ormachine_list for each role
		set NETQE_NIC_MACHINE($role) [exec parse_netqe_nic_info.sh -P "$pciid" -d "$driver" -m "$model" -s "$speed" -p "$match" -v "$unmatch" -c "$num"]
		incr M 1
	} {
		set NETQE_NIC_MACHINE($role) {}
	}
}

set jobCtl {!}
set wbCtl {-}
set notifyCtl {!}
if [info exist Opt(recipe)] {
	set jobCtl {c}
	set wbCtl {_}
	set notifyCtl {C}
}

set jobOwner {}
if [info exist Opt(job-owner)] {
	set jobOwner $Opt(job-owner)
}

set groupOwner {}
if [info exist Opt(group-owner)] {
	set groupOwner $Opt(group-owner)
}

set taskN 1
if [info exist Opt(taskn)] {
	set taskN $Opt(taskn)
}

set retentionTag "60days"
set productkv {}
if [info exist Opt(retention-tag)] {
	set retentionTag $Opt(retention-tag)
	if [info exist Opt(product)] {
		set productkv product=$Opt(product)
	}
}

proc makeTag {taginfo} {
	if {[string range $taginfo 0 2] == "kv-"} {
		set t [string range $taginfo 3 end]
		lassign [regsub (.*?)(=|!=|>|>=|<|<=|~)(.*$) $t {key=\1 op=\2 {value=\3}}] k op v
		if {$op == "op=~"} {set op "op=like"}
		if [string match {*%*} $v] {set op "op=like"}
		doTag key_value $k $op $v -
	} else {
		set _tag [split $taginfo ,]
		set _tag0 [lindex $_tag 0]
		set _attrs [list]
		if {[llength $_tag] > 1} {lappend _attrs {*}[lrange $_tag 1 end]}

		lassign [regsub (.*?)(:|=|!=|>|>=|<|<=|~)(.*$) $_tag0 {\1 op=\2 {value=\3}}] t op v
		if {$op == "op=~"} {set op "op=like"}
		if [string match {*%*} $v] {set op "op=like"}
		if {$op == "op=:"} {
			set _attrs [linsert $_attrs 0 [string range $v 6 end]]
		} else {
			set _attrs [linsert $_attrs 0 $op $v]
		}
		doTag $t {*}$_attrs -
	}
}

# start generate xml
job retention_tag=$retentionTag $productkv user=$jobOwner group=$groupOwner $jobCtl {
	if ![info exist Opt(wb)] {
		set Time [clock format [clock seconds] -format %Y-%m-%d~%H:%M]
		set Opt(wb) "\[$Time\] $DISTRO_L \\[llength $TaskList]/[file tail [lindex [lindex $TaskList 0] 0]],... arch=$ARCH_L "
	}

	whiteboard $wbCtl "<!\[CDATA\[$Opt(wb)]]>"
	notify $notifyCtl {
		if [info exist Opt(cc)] {
			foreach e $Opt(cc) {
				foreach m [split $e ", "] { cc - $m }
			}
		}
	}
	recipeSet priority=$Opt(priority) ! {
		set SystemType "Machine"
		set VARIANT {}
		set DISTRO {}
		set FAMILY {}
		set TAG {}
		set R {0};	# Role index
		foreach role ${ROLE_LIST} {
			set current_bootcTo ""
			set current_bootc_mode ""
			append current_recipe_ks_meta $recipe_ks_meta
			if {[info exist bootcToList]} {
				set current_bootcTo [lindex $bootcToList $R]
				set current_bootc_mode [lindex $bootc_mode_list $R]
			}
			if {$current_bootc_mode == "fromPkgMode"} {
				set Switch2BootcTask $defaultSwitch2BootcFromPkgModeTask
				# https://beaker-project.org/user-guide/customizing-partitions.html
				append current_recipe_ks_meta " no_autopart "
			} elseif {$current_bootc_mode == "fromImageMode"} {
				set Switch2BootcTask $defaultSwitch2BootcFromImageModeTask
			} elseif {${current_bootc_mode} == "fromImageModeDirect"} {
				set current_bootc_direct [lindex $bootc_direct_list $R]
			} else {
				set Switch2BootcTask ""
			}
			set ksfContent $roleKsfContents($R)
			set role_bootc_ksAppend $roleBootcKsAppends($R)
			# use for bootc tasks
			set PART_MPS ""
			# use as normal tasks
			set partList ""
			if {${current_bootc_mode} eq "fromPkgMode"} {
				if {[regexp {/nfs(-utils)?/|=nfs} [join $TaskList " "]]} {
					lappend partList {fs=ext4 name=/var/nfsshare size=5 type=part}
				}
			}
			# below check also effected the # partitions ! 
			if [info exist Opt(part)] {
				foreach part $Opt(part) {
					lappend partList $part
				}
			}
			foreach part $partList {
				append PART_MPS [regsub {.*name=([^ ]+).*} $part {\1}],
			}

			if [llength $DISTRO_L] {
				set DISTRO [lindex $DISTRO_L 0]
				set DISTRO_L [lrange $DISTRO_L 1 end]
			}
			if [llength $FAMILY_L] {
				set FAMILY [lindex $FAMILY_L 0]
				set FAMILY_L [lrange $FAMILY_L 1 end]
			}
			if [llength $TAG_L] {
				set TAG [lindex $TAG_L 0]
				set TAG_L [lrange $TAG_L 1 end]
			}
			if [llength $ARCH_L] {
				set ARCH [lindex $ARCH_L 0]
				set ARCH_L [lrange $ARCH_L 1 end]
			}

			lassign [split $ARCH .] ARCH Vendor
			if ![string length $ARCH] {set ARCH auto}
			if [string equal $ARCH "auto"] {set ARCH x86_64}

			set MACHINE {}
			if [llength $MACHINE_L] {
				set MACHINE [lindex $MACHINE_L 0]
				set MACHINE_L [lrange $MACHINE_L 1 end]
				#if {[string length $MACHINE] > 0} { set ARCH {} }
			}

			set KOPTS ""
			set KOPTS_POST ""
			if [info exist Opt(k-opts)] {
				set KOPTS {*}$Opt(k-opts)
				if {[llength $Opt(k-opts)] > 1} { set KOPTS {*}[lindex $Opt(k-opts) $R]}
			}
			if [info exist Opt(k-opts-post)] {
				set KOPTS_POST {*}$Opt(k-opts-post)
				if {[llength $Opt(k-opts-post)] > 1} { set KOPTS_POST {*}[lindex $Opt(k-opts-post) $R]}
			}
			set recipe_wb $Opt(wb)
			if [info exist Opt(rwb)] { set recipe_wb "$Opt(rwb)" }

			lappend Opt(dr)
			lappend Opt(hr)
			set drs $Opt(dr)
			set hrs $Opt(hr)

			if [info exist Opt(lab)] {
				if {[catch {exec bkr labcontroller-list} lablist] != 0} {
					puts stderr "{Warn} run bkr labcontroller-list fail"
				}
				foreach lab [split $Opt(lab) ",/"] {
					lappend hrs or:labcontroller=[lsearch -inline $lablist "*${lab}*"]
				}
			}

			recipe kernel_options=$KOPTS kernel_options_post=$KOPTS_POST whiteboard=$recipe_wb ks_meta=$current_recipe_ks_meta ! {
				set pick "false"
				if [info exist Opt(random)] {set pick "true"}
				doTag autopick random=$pick -

				if {[info exist Opt(packages)]} {
					if { ${current_bootc_mode} == "no" || ${current_bootc_mode} == "" } {
						doTag packages ! {
							foreach pkg [split $Opt(packages) ",/ "] {
								doTag package name=$pkg -
							}
						}
					}
				}

				if {${current_bootc_mode} ne "no" && ${current_bootc_mode} ne "fromImageModeDirect"} {
					if {$current_bootcTo != "" && $current_bootcTo != "followDistro"} {
						set DISTRO $current_bootcTo
					}
				}
				if ![info exist Opt(standalone)] {
				distroRequires ! {
					and ! {
						if [llength $VARIANT_L] {
							set VARIANT [lindex $VARIANT_L 0]
							set VARIANT_L [lrange $VARIANT_L 1 end]
						}
						if {[string match Fedora* $DISTRO] && $VARIANT == ""} {set VARIANT Everything}
						lappend drs distro_method=${METHOD}

						if [info exist Opt(DR)] {
							set DRs [lindex $Opt(DR) $R]
							if {$DRs != ""} {lappend drs {*}[split $DRs " "]}
						}

						set FamilyX {}
						set FamilyY {}
						set FamilyZ {}
						set DistroPattern {}
						set _FAMILY $FAMILY
						if {[string match family* $DISTRO] || $DISTRO == ""} {
							if {$_FAMILY == ""} {
								lassign [split [string map {family ""} $DISTRO] .] FamilyX FamilyY FamilyZ
								set _FAMILY "RedHatEnterpriseLinux$FamilyX"
							} elseif [regexp -- {^[0-9]} ${_FAMILY}] {
								set _FAMILY "RedHatEnterpriseLinux${_FAMILY}"
							}
							if {[lsearch -glob $drs distro_family=*] == -1} {lappend drs distro_family=${_FAMILY}}
							if {[lsearch -glob $drs distro_tag=*] == -1} {lappend drs distro_tag=${TAG}}
							set verx [string map {RedHatEnterpriseLinux ""} $_FAMILY]
							if {$verx >= 8} {set VARIANT BaseOS}
							if {$FamilyY != ""} {
								if {$FamilyZ == ""} {
									set DistroPattern RHEL-${FamilyX}.${FamilyY}.%
								} else {
									set DistroPattern RHEL-${FamilyX}.${FamilyY}.${FamilyZ}-%
								}
								lappend drs distro_name~${DistroPattern}
							}
						} else {
							if {[lsearch -glob $drs distro_name=*] == -1} {
								if {[string match *%* ${DISTRO}]} {
									lappend drs distro_name~${DISTRO}
								} else {
									lappend drs distro_name=${DISTRO}
								}
							}
						}
						lappend drs distro_variant=$VARIANT

						if {[lsearch -glob $drs distro_arch=*] == -1} {
							set distro_arch $ARCH
							if {$ARCH == "" && [string length $MACHINE] > 0} {
								set hostinfo [exec bash -c "curl -L -k -s $bkrurl/systems/$MACHINE; :"]
								set hidict [json2dict $hostinfo]
								if [dict exists $hidict arches] {
									set distro_arch [lindex [dict get $hidict arches] end]
								}
							}
							if [info exist Opt(HR)] {
								set HRs [lindex $Opt(HR) $R]
								set archindex [lsearch -glob $HRs arch=*]
								if {$archindex != -1} {
									set distro_arch [string range [lindex $HRs $archindex] 5 end]
								}
							}
							lappend drs distro_arch=${distro_arch}
						}

						foreach taginfo [lsearch -regexp -inline -all -not $drs {^(top|or|not)[-:]}] {
							makeTag $taginfo
						}
					}

					foreach taginfo [lsearch -glob -inline -all $drs {top[-:]*}] {
						set taginfo [string range $taginfo 4 end]
						makeTag $taginfo
					}

					or ! {
						foreach taginfo [lsearch -glob -inline -all $drs {or[-:]*}] {
							set taginfo [string range $taginfo 3 end]
							makeTag $taginfo
						}
					}
					not ! {
						or ! {
							foreach taginfo [lsearch -glob -inline -all $drs {not[-:]*}] {
								set taginfo [string range $taginfo 4 end]
								makeTag $taginfo
							}
						}
					}
				}

				set distroBuild $DISTRO
				set forceMachine {}
				if [string match force:* $MACHINE] {
					set MACHINE [string range $MACHINE 6 end]
					set forceMachine "force=$MACHINE"
				}

				hostRequires $forceMachine ! {
					and ! {
						if {[string length $MACHINE] > 0} {
							hostname op=like value=$MACHINE -
						} else {
							if {[string equal ${ARCH} "x86_64"]} {
								if {[regexp {(RHEL|latest)-1[0-9].*} $distroBuild]} { set amd64v3 yes }
								if {[info exist amd64v3]} {
									lappend hrs kv-CPUFLAGS=avx2 kv-CPUFLAGS=bmi2 kv-CPUFLAGS=f16c kv-CPUFLAGS~fma% kv-CPUFLAGS~abm% kv-CPUFLAGS~movbe% kv-CPUFLAGS~xsave%
								}
							}
							lappend hrs not:kv-DISKSPACE>=10000000
							lappend hrs not:cpu_count>=256
							lappend hrs not:memory>=500000

							if [info exist Opt(sr)] {lappend hrs {*}[lmap e $Opt(sr) {format "system.%s" $e}]}
							if {$Vendor != ""} {lappend Opt(kv) CPUVENDOR=$Vendor}
							if [info exist Opt(kv)] {lappend hrs {*}[lmap e $Opt(kv) {
								lassign [regsub (.*?)(=|!=|>|>=|<|<=|~)(.*$) $e {key=\1 op=\2 {value=\3}}] k op v
								if {$op == "op=~"} {set op "op=like"}
								format "key_value:%s,%s,%s" $k $op $v
							}]}

							if [info exist Opt(HR)] {
								set HRs [lindex $Opt(HR) $R]
								if {$HRs != ""} {lappend hrs {*}[split $HRs " "]}
							}
							if {[lsearch -glob $hrs arch=*] == -1} {
								lappend hrs arch=$ARCH
							}

							foreach taginfo [lsearch -regexp -inline -all -not $hrs {^(top|or|not)[-:]}] {
								makeTag $taginfo
							}

							if [info exist Opt(hrxml)] {
								puts "\n$Opt(hrxml)"
							}
						}
					}

					if [llength $SystemTypeList] {
						set SystemType [lindex $SystemTypeList 0]
						set SystemTypeList [lrange $SystemTypeList 1 end]
					}
					system_type op== value=${SystemType} -

					foreach taginfo [lsearch -glob -inline -all $hrs {top[-:]*}] {
						set taginfo [string range $taginfo 4 end]
						makeTag $taginfo
					}

					if {[string length $MACHINE] == 0} {
						or ! {
							foreach m "$ORMACHINE_L $NETQE_NIC_MACHINE($role)" {
								hostname op=like value=$m -
							}
							foreach taginfo [lsearch -glob -inline -all $hrs {or[-:]*}] {
								set taginfo [string range $taginfo 3 end]
								makeTag $taginfo
							}
						}
						not ! {
							or ! {
								foreach taginfo [lsearch -glob -inline -all $hrs {not[-:]*}] {
									set taginfo [string range $taginfo 4 end]
									makeTag $taginfo
								}
							}
						}
					}
				}
				repos ! {
					set REPOS ""
					if {${nrestraint} eq "yes"} {
						if {${restraintrepo} eq {}} {
							set current_restraintrepo [get_nrestraint_repo $DISTRO]
						} else {
							set current_restraintrepo ${restraintrepo}
						}
					} else {
						set current_restraintrepo {}
					}
					if {${current_restraintrepo} ne {}} {
						repo name=restraint "url=${current_restraintrepo}" -
					}
					if [info exist Opt(repo)] {
						set i 0
						foreach url $Opt(repo) {
							if {"${current_bootc_mode}" == "no" || "${current_bootc_mode}" == "" } {
								repo name=myrepo_[incr i] url=$url -
							}
							append REPOS "${url},"
						}
					}
				}
				partitions ! {
					if [info exist partList] {
						#set partList $Opt(part)
						foreach part $partList {
							partition {*}$part -
						}
					}
				}
				#end ![info exist Opt(standalone)]
				} else {
					set distroBuild $DISTRO
					set kpchgsParam "keepchanges=$kpchgs"
				}

				if {[info exist Opt(reserve-if-fail)]} { set WATCHDOG_PANIC ignore }
				if {[info exist WATCHDOG_PANIC]} {
					watchdog panic=$WATCHDOG_PANIC -
				}

				### tasks nodes
				## gen insert-tasks list
				set insertTasks [list]

				# distro build
				if [string match family* $DISTRO] {
					if {[info exist DistroPattern] && $DistroPattern != ""} {
						set distroBuild [exec bash -c "bkr distro-trees-list --arch $ARCH --family $_FAMILY --name $DistroPattern --limit=1 | awk '/Name:/{print \$2}'"]
					} else {
						set distroBuild [exec bash -c "bkr distro-trees-list --arch $ARCH --family $_FAMILY --limit=1 | awk '/Name:/{print \$2}'"]
					}
				}
				# kernel nvr option

				if [llength $NVR_L] {
					set NVR [lindex $NVR_L 0]
					if {$NVR in {"" "{}"}} {
						set NVR [getDefaultNVR $DISTRO]
					}
					set NVR_L [lrange $NVR_L 1 end]
				}
				if ![info exist NVR] { set NVR {} }
				set brewBuildList ""
				if {[info exist Opt(dbgk)] && $NVR in {"" "{}"}} {
					append brewBuildList "-debugk "
				}
				if [info exist Opt(Brew)] {
					foreach build $Opt(Brew) { append brewBuildList $build " " }
				}
				if [info exist Opt(brew)] {
					set _build [lindex $Opt(brew) $R]
					if {$_build == ""} {set _build "vim"}
					append brewBuildList "${_build} "
				}
				# distro install
				if ![info exist distroBuild] { set distroBuild {} }
				# if current_bootc_mode equal "", means runtest didn't receive --bootc
				if {[string length $distroBuild] > 1 && (${current_bootc_mode} eq "" || ${current_bootc_mode} eq "fromImageModeDirect")} {
					lappend insertTasks "$OSInstaller DISTRO_BUILD=$distroBuild"
				} elseif { ${current_bootc_mode} eq "no" && [llength $brewBuildList] == 0 } {
					lappend insertTasks "$OSInstaller DISTRO_BUILD=$distroBuild"
				}

				#bootc_mode
				if {[info exist bootcToList]} {
					if {$current_bootc_mode ne "no" && $current_bootc_mode ne "fromImageModeDirect" && $current_bootc_mode ne ""} {
						if {[llength $brewBuildList] > 0} { set ContainerBPkgs $brewBuildList }
						if [info exist Opt(packages)] { set ContainerPkgs [split $Opt(packages) ",/ "] }
						lappend insertTasks "$Switch2BootcTask DISTRO_BUILD=$distroBuild BOOTC_TO=$current_bootcTo {PKGS=$ContainerPkgs} {BPKGS=$ContainerBPkgs} {ScriptUrl=$ContainerScriptUrl} {PART_MPS=$PART_MPS} {REPOS=$REPOS} {KOPTS=$KOPTS} KILLTIMEOVERRIDE=345600"
					}
				}

				# command before kernelinstall
				if [info exist Opt(cmdb)] {
					foreach cmd $Opt(cmdb) {
						lappend insertTasks "/distribution/command {CMDS_TO_RUN=$cmd}"
					}
				}

				# pkg install
				if [info exist Opt(install)] {
					foreach pkg $Opt(install) {
						lappend insertTasks "/distribution/pkginstall {PKGARGNAME=$pkg} VERLOCK=yes"
					}
				}

				# kernel install
				set UP ""
				if {$NVR ni {"" "{}"}} {
					if ![regexp {^upstream.*} $NVR] {
						set KN [regsub {((^[a-z][a-z0-9-]*)-)?.*} $NVR {\2}]
						if {$KN == ""} {set KN kernel}
						set KVR [regsub {^[a-z0-9-]*-} $NVR {}]
						set params [list]
						lappend params KERNELARGNAME=$KN KERNELARGVERSION=$KVR KERNELARGVARIANT=$KVARIANT NoDeps=--nodeps
						lappend insertTasks "/kernel-tests/distribution/kernelinstall $params"
					} else {
						set UP [regsub {^upstream} $NVR {}]
						set UP [regsub {^[:=]} $UP {}]

						set upstreamUrl git://git.app.eng.bos.redhat.com/linux.git
						set upstreamBranch master
						set upstreamTag HEAD
						if {$UP != ""} {
							lassign [split $UP] url_branch tag
							lassign [split $url_branch "#"] url branch
							if {[string trim $url] != ""} {set upstreamUrl $url}
							if {[string trim $branch] != ""} {set upstreamBranch $branch}
							if {[string trim $tag] != ""} {set upstreamTag $tag}
						}
						set UP 1
					}
				}
				if {[info exist Opt(upstream)] || $UP != ""} {
					set params [list]
					lappend params KERNEL_GIT_REPO=$upstreamUrl KERNEL_GIT_BRANCH=$upstreamBranch KERNEL_GIT_COMMIT=$upstreamTag GIT_CLONE_OPTION=--depth=1 ABORT_IF_FAIL=1
					if [info exist Opt(upstream-use-clone)] {
						lappend params USE_GIT_CLONE=1 GIT_CLONE_OPTION=$Opt(upstream-use-clone)
					}
					if [info exist Opt(upstream-kernel-kasan)] {
						lappend params ENABLE_KASAN=1
					}
					if [info exist Opt(upstream-patch)] {
						lappend params PATCH_URLS=$Opt(upstream-patch)
					}
					lappend insertTasks "/kernel/distribution/upstream-kernel/install $params"

				}
				if {[info exist Opt(kpatch)]} {
					lassign [split $Opt(kpatch) {,}] knvr kpnvr kpurl
					set params [list]
					lappend params KERNELARGVARIANT=up KERNELARGNAME=kernel KERNELARGVERSION=[string map {"kernel-" {}} $knvr] KPATCHNVR=$kpnvr KPATCHURL=$kpurl
					lappend insertTasks "/distribution/kpatchinstall $params"
				}
				if {[llength $brewBuildList] > 0 && (${current_bootc_mode} == "no" || ${current_bootc_mode} == "")} {
					lappend insertTasks "/distribution/brew-build-install {BUILDID=$brewBuildList} AVC_ERROR=+no_avc_check"
				}

				# --kdump task
				if {[info exist Opt(kdump)] && ![info exist Opt(nokdump)]} {
					set kdumpAddr $Opt(kdump)
					if {$kdumpAddr == "" && [info exist KDUMP_ADDR]} {
						set kdumpAddr $KDUMP_ADDR
					}
					lassign [regsub (.*?):(/.*$) $kdumpAddr {\1 {\2}}] NFSSERVER VMCOREPATH
					if {[string length $NFSSERVER] == 0 || [string length $VMCOREPATH] == 0} {
						set NFSSERVER "fs-qe.usersys.redhat.com"
						set VMCOREPATH "/workspace/vmcore"
					}
					set nfsDumpTask [list /kernel/kdump/setup-nfsdump NFSSERVER=${NFSSERVER} VMCOREPATH=${VMCOREPATH} NO_COMPRESS=1 AVC_ERROR=+no_avc_check]
					if {[info exist Opt(crashsize)]} {
						set kdumpCrashsize $Opt(crashsize)
						append nfsDumpTask " CRASHSIZE=${kdumpCrashsize}"
					}
					lappend insertTasks $nfsDumpTask
				}

				# enable fips
				if [info exist Opt(fips)] {
					set FIPS {1}
					if [llength $FIPS_L] {
						set FIPS [lindex $FIPS_L 0]
						set FIPS_L [lrange $FIPS_L 1 end]
					}
					if {$FIPS ni {"0"}} {
						lappend insertTasks "/distribution/fips/setup-fips-enabled"
					} else {
						lappend insertTasks "/distribution/fips/setup-fips-disabled"
					}
				}

				# enable abrt
				if [info exist Opt(abrt)] {
					lappend insertTasks "/distribution/crashes/enable-abrt"
				}

				# command after kernelinstall
				if [info exist Opt(cmd)] {
					foreach cmd $Opt(cmd) {
						lappend insertTasks "/distribution/command {CMDS_TO_RUN=$cmd}"
					}
				}
				if [info exist Opt(cmd-and-reboot)] {
					foreach cmd $Opt(cmd-and-reboot) {
						lappend insertTasks "/distribution/command {CMDS_TO_RUN=$cmd}"
					}
					lappend insertTasks "/distribution/utils/reboot"
				}
				# --kcov --gcov task
				if [info exist Opt(kcov)] {
					if {$Opt(kcov) != ""} {
						set kdir $Opt(kcov)
					} elseif [info exist KCOV_PARAM] {
						set kdir $KCOV_PARAM
					} else {
						set kdir "fs, net, drivers/net"
					}

					lappend insertTasks "/kernel/kcov/prepare MODE=KA {KDIR=$kdir}"
					lappend insertTasks "/kernel/kcov/start"
				}
				if [info exist Opt(gcov)] {
					lappend insertTasks "/kernel/kcov/gcov-userspace-start PACKAGE_NAME=$Opt(gcov)"
				}

				# --leap-second
				if [info exist Opt(leap-second)] {
					lappend insertTasks "/kernel/general/time/leap-second/ins_leap_sec"
				}

				if [info exist Opt(insert-task)] {
					lappend insertTasks {*}$Opt(insert-task)
				}

				## gen append-tasks list
				set appendTasks [list]
				if [info exist Opt(append-task)] {
					lappend appendTasks {*}$Opt(append-task)
				}

				# --kcov --gcov task
				if [info exist Opt(kcov)] {
					lappend appendTasks "/kernel/kcov/end KILLTIMEOVERRIDE=345600"
					lappend appendTasks "/kernel/kcov/finalize"
					#lappend appendTasks "/kernel/kcov/finalize NFS_SHARE=$NFS_SHARE TASKNAME=$TASKNAME"
				}
				if [info exist Opt(gcov)] {
					lappend appendTasks "/kernel/kcov/gcov-userspace-end PACKAGE_NAME=$Opt(gcov)"
				}

				# command in the end of the recipe
				if [info exist Opt(cmd-end)] {
					foreach cmd $Opt(cmd-end) {
						lappend appendTasks "/distribution/command {CMDS_TO_RUN=$cmd}"
					}
				}

				# --reserve-if-fail
				if [info exist Opt(reserve-if-fail)] {
					set ReserveTime {356400}
					if {[string length $Opt(reserve-if-fail)] > 0} {
						set ReserveTime $Opt(reserve-if-fail)
					}
					lappend appendTasks "/distribution/reservesys RESERVETIME=${ReserveTime} RESERVE_IF_FAIL=1"
				}
				# --reserve
				if [info exist Opt(reserve)] {
					set ReserveTime {356400}
					if {[string length $Opt(reserve)] > 0} {
						set ReserveTime $Opt(reserve)
					}
					lappend appendTasks "/distribution/reservesys RESERVETIME=${ReserveTime}"
				}

				# prefetch all testcases
				ks_appends ! {
					if [info exist Opt(repo-post)] {
						ks_append ! {
							puts {<![CDATA[}
							puts {%post}
							set i 0
							foreach url $Opt(repo-post) {
								puts "cat <<-'EOF' >/etc/yum.repos.d/beaker-kernel$i.repo
								\[beaker-kernel$i\]
								name=beaker-kernel$i
								baseurl=$url
								enabled=1
								gpgcheck=0
								skip_if_unavailable=1
								EOF"
								incr i
							}
							puts {%end}
							puts -nonewline {]]>}
						}
					}
					if {$role_bootc_ksAppend != ""} {
						ks_append ! {
							puts "<!\[CDATA\[\n$role_bootc_ksAppend\]\]>"
						}
					}
					if {$ksAppend != ""} {
						ks_append ! {
							puts "<!\[CDATA\[\n$ksAppend\]\]>"
						}
					}

					ks_append ! {
						puts "<!\[CDATA\[\n$ksfContent\]\]>"
					}

					set testRepoList [list]
					# Modify the condition judgment: when current_bootc_direct is "_", prefetching is also required
					if {(![string match fromImage* ${current_bootc_mode}] || (${current_bootc_mode} == "fromImageModeDirect" && ${current_bootc_direct} == "_")) && ([info exist Opt(keepchanges)] || $nrestraint eq "yes")} {
						array set repoUrls {}
						array set repoRpaths {}
						set taskList [list]
						if {[info exists ::Opt(autopath)]} {
							set taskList [concat ${insertTasks} ${TaskList} ${appendTasks}]
						} else {
							set taskList [concat ${insertTasks} ${TaskList} ${appendTasks}]
						}
						foreach _task $taskList {
							set _fetch_url yes
							set taskname [lindex $_task 0]
							lassign [split ${taskname} {@}] taskname inUri
							set taskparams [lrange $_task 1 end]
							set testRepo /[lrange [file split $taskname] 1 1]
							set testPath [regsub {^/?[^/]+/} $taskname {}]
							lassign [gettask_uri_and_opts $taskname $inUri] uri _uopts
							regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_fetch_from_*=*] _ _fetch_url
							if {$_fetch_url ne "disable" && $uri ne ""} {
								if {![regexp "${testRepo}@" ${taskname2urlOpts}]} {
									set rurl [regsub {#.*$} ${uri} {}]
									if {![info exist repoUrls($testRepo)]} {
										set repoUrls($testRepo) "$rurl"
									} else {
										append repoUrls($testRepo) "\n$rurl"
									}
								}
								lappend testRepoList "$testRepo"
								if {![info exist repoRpaths($testRepo)]} {
									set repoRpaths($testRepo) "$testPath"
								} else {
									append repoRpaths($testRepo) "\n$testPath"
								}
							}
						}
						foreach {repo urls} [array get repoUrls] {
							set _prefix [longestCommonPrefix $repoUrls($repo)]
							if [string match {*?path=} $_prefix] {
								append taskname2urlOpts " -repo=${repo}@${_prefix}"
							} else {
							}
						}
						set _ksfContent ""
						set _ksfContent "%post --log=/root/ks-fetch-uri.log\n"
						append _ksfContent "yum install -y bzip2 xz\n"
						foreach taskrepo [lsort -unique $testRepoList] {
							lassign [gettask_uri_and_opts $taskrepo ""] uri _uopts
							if {[info exists ::Opt(autopath)]} {
								set prefix [longestCommonPrefix $repoRpaths($taskrepo)]
								regsub -line {/$} $prefix {} prefix
								if {$prefix ni ""} { set uri [regsub {(\?.*)?$} $uri "?path=$prefix"] }
							}
							if {![string match {*gitlab*} $uri]} {
								set uri [regsub {(\?.*)?$} $uri {}]
							}
							if {$uri ne ""} {
								append _ksfContent "echo {run} rstrnt-prefetch.sh -fetch.done.mark $uri\n"
								append _ksfContent "rstrnt-prefetch.sh -fetch.done.mark $uri\n"
								append _ksfContent "echo ----------------------------------------------------------------;\n"
							}
						}
						append _ksfContent "cmd='ls -lh /mnt/tests'; echo {run} \$cmd; \$cmd;\n"
						append _ksfContent "%end\n"
						append _ksfContent "%post\ncat /root/ks-fetch-uri.log >/dev/ttyS0\n%end\n"
						ks_append ! {
							puts "<!\[CDATA\[\n$_ksfContent\]\]>"
						}
					}
				}

				# gen tasks nodes
				foreach taskb $insertTasks {
					set taskname [lindex $taskb 0]
					lassign [split ${taskname} {@}] taskname inUri
					set taskparams [lrange $taskb 1 end]
					set insert 1
					lassign [list $role "" enable ""] _role _roleval _fetch_url _task_position
					regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_role=*] _ _roleval
					regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_fetch_from_*=*] _ _fetch_url
					if {$_roleval ne ""} { set _role $_roleval }
					regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_position=*] _ _task_position
					if {$_task_position ne ""} { set insert [lindex [split $_task_position ,] $R] }

					if {$insert in {1 y yes}} {
						lassign [gettask_uri_and_opts $taskname $inUri] uri _uopts
						set opts "${task-fetch-opts} ${_uopts}"
						if {$uri == ""} { set opts {} } else { lappend taskparams "_fetch_opts=$opts"}
						task name=$taskname role=$_role ${kpchgsParam} ! {
							if {$_fetch_url ne "disable"} {
								fetchtag $uri
							}
							params ! {
								if {$uri == ""} {param name=_FETCH_URL value=no -}
								foreach taskparam $taskparams {
									if [regexp {^(_task|_desc)} $taskparam] continue
									lassign [regsub {(^[^=]*)=(.*)} $taskparam {\1 {\2}}] pname pvalue
									# use "mh-" prefix to set different value for multihost
									if [regexp {^mh-} $pname] {
										set pname [string range $pname 3 end]
										set pvalue_list [split $pvalue ,]
										param name=$pname value=[lindex $pvalue_list $R] -
									} else {
										param name=$pname value=$pvalue -
									}
								}
								#param name=DISTRO_BUILD value=$distroBuild -
							}
						}
					} else {
						set taskname $dummytask
						lassign [gettask_uri_and_opts $taskname ""] uri _uopts
						set opts "${task-fetch-opts} ${_uopts}"
						if {$uri == ""} { set opts {} } else { lappend taskparams "_fetch_opts=$opts"}
						task name=$taskname role=$_role ${kpchgsParam} ! {
							fetchtag $uri
						}
					}
				}

				# task list
				set llen [llength ${TaskList}]
				for {set i 0} {$i < $taskN} {incr i} {
					set iter 1
					foreach task ${TaskList} {
						set name [lindex $task 0]
						lassign [split ${name} {@}] name inUri
						if {$name == "/donothing"} continue
						set taskparams [lrange $task 1 end]
						set insert 1
						lassign [list $role "" enable ""] _role _roleval _fetch_url _task_position
						regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_role=*] _ _roleval
						regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_fetch_from_*=*] _ _fetch_url
						if {$_roleval ne ""} { set _role $_roleval }
						regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_position=*] _ _task_position
						if {$_task_position ne ""} { set insert [lindex [split $_task_position ,] $R] }
						regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _desc=*] _ _desc

						if {$insert in {1 y yes}} {
							lassign [gettask_uri_and_opts $name $inUri] uri _uopts
							if {![info exist _desc]} { set _desc ${tasksDesc} }
							set opts "${task-fetch-opts} ${_uopts}"
							if {$uri == ""} { set opts {} } else { lappend taskparams "_fetch_opts=$opts"}
							task name=$name${_desc} role=$_role ${kpchgsParam} ! {
								if {$_fetch_url ne "disable"} {
									fetchtag $uri
								}
								params ! {
									if {$uri == ""} {param name=_FETCH_URL value=no -}
									foreach taskparam $taskparams {
										if [regexp {^(_task|_desc)} $taskparam] continue
										if [regexp {^DISTRO_BUILD=} $taskparam] continue
										lassign [regsub {(^[^=]*)=(.*)} $taskparam {\1 {\2}}] pname pvalue
										# use "mh-" prefix to set different value for multihost
										if [regexp {^mh-} $pname] {
											set pname [string range $pname 3 end]
											set pvalue_list [split $pvalue ,]
											param name=$pname value=[lindex $pvalue_list $R] -
										} else {
											param name=$pname value=$pvalue -
										}
									}
									param name=DISTRO_BUILD value=$distroBuild -
								}
							}
						} else {
							set name $dummytask
							lassign [gettask_uri_and_opts $name ""] uri _uopts
							set opts "${task-fetch-opts} ${_uopts}"
							if {$uri == ""} { set opts {} } else { lappend taskparams "_fetch_opts=$opts"}
							task name=$name${tasksDesc} role=$_role ${kpchgsParam} ! {
								fetchtag $uri
							}
						}

						if {[info exist Opt(reboot)] && $iter < $llen} {
							task name=/distribution/utils/reboot role=$role ${kpchgsParam} -
						}
						incr iter
					}
				}

				foreach taska $appendTasks {
					set taskname [lindex $taska 0]
					lassign [split ${taskname} {@}] taskname inUri
					set taskparams [lrange $taska 1 end]
					set insert 1
					lassign [list $role "" enable ""] _role _roleval _fetch_url _task_position
					regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_role=*] _ _roleval
					regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_fetch_from_*=*] _ _fetch_url
					if {$_roleval ne ""} { set _role $_roleval }
					regexp {^[^=]+=(.*)$} [lsearch -inline $taskparams _task_position=*] _ _task_position
					if {$_task_position ne ""} { set insert [lindex [split $_task_position ,] $R] }

					if {$insert in {1 y yes}} {
						lassign [gettask_uri_and_opts $taskname $inUri] uri _uopts
						set opts "${task-fetch-opts} ${_uopts}"
						if {$uri == ""} { set opts {} } else { lappend taskparams "_fetch_opts=$opts"}
						task name=$taskname role=$_role ${kpchgsParam} ! {
							if {$_fetch_url ne "disable"} {
								fetchtag $uri
							}
							params ! {
								if {$uri == ""} {param name=_FETCH_URL value=no -}
								foreach taskparam $taskparams {
									if [regexp {^(_task|_desc)} $taskparam] continue
									lassign [regsub {(^[^=]*)=(.*)} $taskparam {\1 {\2}}] pname pvalue
									# use "mh-" prefix to set different value for multihost
									if [regexp {^mh-} $pname] {
										set pname [string range $pname 3 end]
										set pvalue_list [split $pvalue ,]
										param name=$pname value=[lindex $pvalue_list $R] -
									} else {
										param name=$pname value=$pvalue -
									}
								}
							}
							#param name=DISTRO_BUILD value=$distroBuild -
						}
					} else {
						set taskname $dummytask
						lassign [gettask_uri_and_opts $taskname ""] uri _uopts
						set opts "${task-fetch-opts} ${_uopts}"
						if {$uri == ""} { set opts {} } else { lappend taskparams "_fetch_opts=$opts"}
						task name=$taskname role=$_role ${kpchgsParam} ! {
							fetchtag $uri
						}
					}
				}

			}
			set R [ expr $R + 1 ]
		}
	}
}
puts ""
